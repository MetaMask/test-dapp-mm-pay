const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/basic-CL2WxW2N.js","assets/ThemeUtil-DGRYMFAF.js","assets/index-BBKiQ_m1.js","assets/index-DXtJvXki.css","assets/index-BLWJ7NvA.js","assets/w3m-modal-XXDCI2nP.js"])))=>i.map(i=>d[i]);
import{ab as li,ac as Bi,ad as No,ae as F,af as Pi,ag as me,ah as Os,ai as cr,aj as We,ak as lr,al as Po,am as hr,an as ur,ao as So,ap as Oo,aq as dr,ar as _o,as as To,at as gs,au as Ke,av as Ge,aw as Je,ax as rs,ay as pr,az as Ro,aA as Te,aB as Re,P as Mi}from"./index-BBKiQ_m1.js";import{V as $o,X as ko,z as zt,Z as qo,C as Hi,Q as oe,M as xo,r as Fi,x as Uo,e as Pe,t as it,i as nt,s as Yt,Y as Do,G as Lo,u as jo,E as fr,a as te,P as hi,b as S,O as U,S as gr,A as z,c as xe,d as ye,f as wr,g as $t,B as Vi,h as Q,j as ee,k as ge,l as Oe,m as Bo,n as Mo,o as ft,p as Zt,T as Be,q as Qt,v as Ho,w as Fo,y as rt,D as Ye,H as Vo,N as zo,L as Wo,F as Xt,I as Ko,J as Go,K as zi,R as Wi,U as ws,W as Jo}from"./ThemeUtil-DGRYMFAF.js";function as(s,{strict:e=!0}={}){return!s||typeof s!="string"?!1:e?/^0x[0-9a-fA-F]*$/.test(s):s.startsWith("0x")}function Ki(s){return as(s,{strict:!1})?Math.ceil((s.length-2)/2):s.length}const mr="2.23.2";let es={getDocsUrl:({docsBaseUrl:s,docsPath:e="",docsSlug:t})=>e?`${s??"https://viem.sh"}${e}${t?`#${t}`:""}`:void 0,version:`viem@${mr}`};class ht extends Error{constructor(e,t={}){var a;const i=(()=>{var c;return t.cause instanceof ht?t.cause.details:(c=t.cause)!=null&&c.message?t.cause.message:t.details})(),n=t.cause instanceof ht&&t.cause.docsPath||t.docsPath,r=(a=es.getDocsUrl)==null?void 0:a.call(es,{...t,docsPath:n}),o=[e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...r?[`Docs: ${r}`]:[],...i?[`Details: ${i}`]:[],...es.version?[`Version: ${es.version}`]:[]].join(`
`);super(o,t.cause?{cause:t.cause}:void 0),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"}),this.details=i,this.docsPath=n,this.metaMessages=t.metaMessages,this.name=t.name??this.name,this.shortMessage=e,this.version=mr}walk(e){return yr(this,e)}}function yr(s,e){return e!=null&&e(s)?s:s&&typeof s=="object"&&"cause"in s&&s.cause!==void 0?yr(s.cause,e):e?null:s}class vr extends ht{constructor({size:e,targetSize:t,type:i}){super(`${i.charAt(0).toUpperCase()}${i.slice(1).toLowerCase()} size (${e}) exceeds padding size (${t}).`,{name:"SizeExceedsPaddingSizeError"})}}function Wt(s,{dir:e,size:t=32}={}){return typeof s=="string"?Yo(s,{dir:e,size:t}):Zo(s,{dir:e,size:t})}function Yo(s,{dir:e,size:t=32}={}){if(t===null)return s;const i=s.replace("0x","");if(i.length>t*2)throw new vr({size:Math.ceil(i.length/2),targetSize:t,type:"hex"});return`0x${i[e==="right"?"padEnd":"padStart"](t*2,"0")}`}function Zo(s,{dir:e,size:t=32}={}){if(t===null)return s;if(s.length>t)throw new vr({size:s.length,targetSize:t,type:"bytes"});const i=new Uint8Array(t);for(let n=0;n<t;n++){const r=e==="right";i[r?n:t-n-1]=s[r?n:s.length-n-1]}return i}class Qo extends ht{constructor({max:e,min:t,signed:i,size:n,value:r}){super(`Number "${r}" is not in safe ${n?`${n*8}-bit ${i?"signed":"unsigned"} `:""}integer range ${e?`(${t} to ${e})`:`(above ${t})`}`,{name:"IntegerOutOfRangeError"})}}class Xo extends ht{constructor({givenSize:e,maxSize:t}){super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`,{name:"SizeOverflowError"})}}function Kt(s,{size:e}){if(Ki(s)>e)throw new Xo({givenSize:Ki(s),maxSize:e})}function ui(s,e={}){const{signed:t}=e;e.size&&Kt(s,{size:e.size});const i=BigInt(s);if(!t)return i;const n=(s.length-2)/2,r=(1n<<BigInt(n)*8n-1n)-1n;return i<=r?i:i-BigInt(`0x${"f".padStart(n*2,"f")}`)-1n}function ea(s,e={}){return Number(ui(s,e))}const ta=Array.from({length:256},(s,e)=>e.toString(16).padStart(2,"0"));function di(s,e={}){return typeof s=="number"||typeof s=="bigint"?br(s,e):typeof s=="string"?na(s,e):typeof s=="boolean"?sa(s,e):Er(s,e)}function sa(s,e={}){const t=`0x${Number(s)}`;return typeof e.size=="number"?(Kt(t,{size:e.size}),Wt(t,{size:e.size})):t}function Er(s,e={}){let t="";for(let n=0;n<s.length;n++)t+=ta[s[n]];const i=`0x${t}`;return typeof e.size=="number"?(Kt(i,{size:e.size}),Wt(i,{dir:"right",size:e.size})):i}function br(s,e={}){const{signed:t,size:i}=e,n=BigInt(s);let r;i?t?r=(1n<<BigInt(i)*8n-1n)-1n:r=2n**(BigInt(i)*8n)-1n:typeof s=="number"&&(r=BigInt(Number.MAX_SAFE_INTEGER));const o=typeof r=="bigint"&&t?-r-1n:0;if(r&&n>r||n<o){const c=typeof s=="bigint"?"n":"";throw new Qo({max:r?`${r}${c}`:void 0,min:`${o}${c}`,signed:t,size:i,value:`${s}${c}`})}const a=`0x${(t&&n<0?(1n<<BigInt(i*8))+BigInt(n):n).toString(16)}`;return i?Wt(a,{size:i}):a}const ia=new TextEncoder;function na(s,e={}){const t=ia.encode(s);return Er(t,e)}const ra=new TextEncoder;function oa(s,e={}){return typeof s=="number"||typeof s=="bigint"?ca(s,e):typeof s=="boolean"?aa(s,e):as(s)?Ir(s,e):Cr(s,e)}function aa(s,e={}){const t=new Uint8Array(1);return t[0]=Number(s),typeof e.size=="number"?(Kt(t,{size:e.size}),Wt(t,{size:e.size})):t}const Me={zero:48,nine:57,A:65,F:70,a:97,f:102};function Gi(s){if(s>=Me.zero&&s<=Me.nine)return s-Me.zero;if(s>=Me.A&&s<=Me.F)return s-(Me.A-10);if(s>=Me.a&&s<=Me.f)return s-(Me.a-10)}function Ir(s,e={}){let t=s;e.size&&(Kt(t,{size:e.size}),t=Wt(t,{dir:"right",size:e.size}));let i=t.slice(2);i.length%2&&(i=`0${i}`);const n=i.length/2,r=new Uint8Array(n);for(let o=0,a=0;o<n;o++){const c=Gi(i.charCodeAt(a++)),l=Gi(i.charCodeAt(a++));if(c===void 0||l===void 0)throw new ht(`Invalid byte sequence ("${i[a-2]}${i[a-1]}" in "${i}").`);r[o]=c*16+l}return r}function ca(s,e){const t=br(s,e);return Ir(t)}function Cr(s,e={}){const t=ra.encode(s);return typeof e.size=="number"?(Kt(t,{size:e.size}),Wt(t,{dir:"right",size:e.size})):t}function Ji(s){if(!Number.isSafeInteger(s)||s<0)throw new Error("positive integer expected, got "+s)}function la(s){return s instanceof Uint8Array||ArrayBuffer.isView(s)&&s.constructor.name==="Uint8Array"}function Si(s,...e){if(!la(s))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(s.length))throw new Error("Uint8Array expected of length "+e+", got length="+s.length)}function Yi(s,e=!0){if(s.destroyed)throw new Error("Hash instance has been destroyed");if(e&&s.finished)throw new Error("Hash#digest() has already been called")}function ha(s,e){Si(s);const t=e.outputLen;if(s.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}const ms=BigInt(2**32-1),Zi=BigInt(32);function ua(s,e=!1){return e?{h:Number(s&ms),l:Number(s>>Zi&ms)}:{h:Number(s>>Zi&ms)|0,l:Number(s&ms)|0}}function da(s,e=!1){let t=new Uint32Array(s.length),i=new Uint32Array(s.length);for(let n=0;n<s.length;n++){const{h:r,l:o}=ua(s[n],e);[t[n],i[n]]=[r,o]}return[t,i]}const pa=(s,e,t)=>s<<t|e>>>32-t,fa=(s,e,t)=>e<<t|s>>>32-t,ga=(s,e,t)=>e<<t-32|s>>>64-t,wa=(s,e,t)=>s<<t-32|e>>>64-t;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ma(s){return new Uint32Array(s.buffer,s.byteOffset,Math.floor(s.byteLength/4))}const Qi=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function ya(s){return s<<24&4278190080|s<<8&16711680|s>>>8&65280|s>>>24&255}function Xi(s){for(let e=0;e<s.length;e++)s[e]=ya(s[e])}function va(s){if(typeof s!="string")throw new Error("utf8ToBytes expected string, got "+typeof s);return new Uint8Array(new TextEncoder().encode(s))}function Ar(s){return typeof s=="string"&&(s=va(s)),Si(s),s}class Ea{clone(){return this._cloneInto()}}function ba(s){const e=i=>s().update(Ar(i)).digest(),t=s();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>s(),e}const Nr=[],Pr=[],Sr=[],Ia=BigInt(0),ts=BigInt(1),Ca=BigInt(2),Aa=BigInt(7),Na=BigInt(256),Pa=BigInt(113);for(let s=0,e=ts,t=1,i=0;s<24;s++){[t,i]=[i,(2*t+3*i)%5],Nr.push(2*(5*i+t)),Pr.push((s+1)*(s+2)/2%64);let n=Ia;for(let r=0;r<7;r++)e=(e<<ts^(e>>Aa)*Pa)%Na,e&Ca&&(n^=ts<<(ts<<BigInt(r))-ts);Sr.push(n)}const[Sa,Oa]=da(Sr,!0),en=(s,e,t)=>t>32?ga(s,e,t):pa(s,e,t),tn=(s,e,t)=>t>32?wa(s,e,t):fa(s,e,t);function _a(s,e=24){const t=new Uint32Array(10);for(let i=24-e;i<24;i++){for(let o=0;o<10;o++)t[o]=s[o]^s[o+10]^s[o+20]^s[o+30]^s[o+40];for(let o=0;o<10;o+=2){const a=(o+8)%10,c=(o+2)%10,l=t[c],h=t[c+1],u=en(l,h,1)^t[a],d=tn(l,h,1)^t[a+1];for(let f=0;f<50;f+=10)s[o+f]^=u,s[o+f+1]^=d}let n=s[2],r=s[3];for(let o=0;o<24;o++){const a=Pr[o],c=en(n,r,a),l=tn(n,r,a),h=Nr[o];n=s[h],r=s[h+1],s[h]=c,s[h+1]=l}for(let o=0;o<50;o+=10){for(let a=0;a<10;a++)t[a]=s[o+a];for(let a=0;a<10;a++)s[o+a]^=~t[(a+2)%10]&t[(a+4)%10]}s[0]^=Sa[i],s[1]^=Oa[i]}t.fill(0)}class Oi extends Ea{constructor(e,t,i,n=!1,r=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=i,this.enableXOF=n,this.rounds=r,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Ji(i),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=ma(this.state)}keccak(){Qi||Xi(this.state32),_a(this.state32,this.rounds),Qi||Xi(this.state32),this.posOut=0,this.pos=0}update(e){Yi(this);const{blockLen:t,state:i}=this;e=Ar(e);const n=e.length;for(let r=0;r<n;){const o=Math.min(t-this.pos,n-r);for(let a=0;a<o;a++)i[this.pos++]^=e[r++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:i,blockLen:n}=this;e[i]^=t,t&128&&i===n-1&&this.keccak(),e[n-1]^=128,this.keccak()}writeInto(e){Yi(this,!1),Si(e),this.finish();const t=this.state,{blockLen:i}=this;for(let n=0,r=e.length;n<r;){this.posOut>=i&&this.keccak();const o=Math.min(i-this.posOut,r-n);e.set(t.subarray(this.posOut,this.posOut+o),n),this.posOut+=o,n+=o}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Ji(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(ha(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:i,outputLen:n,rounds:r,enableXOF:o}=this;return e||(e=new Oi(t,i,n,o,r)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=r,e.suffix=i,e.outputLen=n,e.enableXOF=o,e.destroyed=this.destroyed,e}}const Ta=(s,e,t)=>ba(()=>new Oi(e,s,t)),Ra=Ta(1,136,256/8);function Or(s,e){const t=e||"hex",i=Ra(as(s,{strict:!1})?oa(s):s);return t==="bytes"?i:di(i)}class $a extends Map{constructor(e){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=e}get(e){const t=super.get(e);return super.has(e)&&t!==void 0&&(this.delete(e),super.set(e,t)),t}set(e,t){if(super.set(e,t),this.maxSize&&this.size>this.maxSize){const i=this.keys().next().value;i&&this.delete(i)}return this}}const Hs=new $a(8192);function ka(s,e){if(Hs.has(`${s}.${e}`))return Hs.get(`${s}.${e}`);const t=s.substring(2).toLowerCase(),i=Or(Cr(t),"bytes"),n=t.split("");for(let o=0;o<40;o+=2)i[o>>1]>>4>=8&&n[o]&&(n[o]=n[o].toUpperCase()),(i[o>>1]&15)>=8&&n[o+1]&&(n[o+1]=n[o+1].toUpperCase());const r=`0x${n.join("")}`;return Hs.set(`${s}.${e}`,r),r}function qa(s){const e=Or(`0x${s.substring(4)}`).substring(26);return ka(`0x${e}`)}async function xa({hash:s,signature:e}){const t=as(s)?s:di(s),{secp256k1:i}=await li(async()=>{const{secp256k1:o}=await import("./secp256k1-IRfSGIr4.js");return{secp256k1:o}},[]);return`0x${(()=>{if(typeof e=="object"&&"r"in e&&"s"in e){const{r:l,s:h,v:u,yParity:d}=e,f=Number(d??u),y=sn(f);return new i.Signature(ui(l),ui(h)).addRecoveryBit(y)}const o=as(e)?e:di(e),a=ea(`0x${o.slice(130)}`),c=sn(a);return i.Signature.fromCompact(o.substring(2,130)).addRecoveryBit(c)})().recoverPublicKey(t.substring(2)).toHex(!1)}`}function sn(s){if(s===0||s===1)return s;if(s===27)return 0;if(s===28)return 1;throw new Error("Invalid yParityOrV value")}async function Ua({hash:s,signature:e}){return qa(await xa({hash:s,signature:e}))}function Da(s=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?globalThis.Buffer.allocUnsafe(s):new Uint8Array(s)}function _r(s,e,t,i){return{name:s,prefix:e,encoder:{name:s,prefix:e,encode:t},decoder:{decode:i}}}const nn=_r("utf8","u",s=>"u"+new TextDecoder("utf8").decode(s),s=>new TextEncoder().encode(s.substring(1))),Fs=_r("ascii","a",s=>{let e="a";for(let t=0;t<s.length;t++)e+=String.fromCharCode(s[t]);return e},s=>{s=s.substring(1);const e=Da(s.length);for(let t=0;t<s.length;t++)e[t]=s.charCodeAt(t);return e}),Tr={utf8:nn,"utf-8":nn,hex:Bi.base16,latin1:Fs,ascii:Fs,binary:Fs,...Bi};function Rr(s,e="utf8"){const t=Tr[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(s,"utf8"):t.decoder.decode(`${t.prefix}${s}`)}function $r(s,e="utf8"){const t=Tr[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(s.buffer,s.byteOffset,s.byteLength).toString("utf8"):t.encoder.encode(s).substring(1)}var La={};const ja=":";function Lt(s){const[e,t]=s.split(ja);return{namespace:e,reference:t}}function kr(s,e){return s.includes(":")?[s]:e.chains||[]}var Ba=Object.defineProperty,Ma=Object.defineProperties,Ha=Object.getOwnPropertyDescriptors,rn=Object.getOwnPropertySymbols,Fa=Object.prototype.hasOwnProperty,Va=Object.prototype.propertyIsEnumerable,on=(s,e,t)=>e in s?Ba(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,an=(s,e)=>{for(var t in e||(e={}))Fa.call(e,t)&&on(s,t,e[t]);if(rn)for(var t of rn(e))Va.call(e,t)&&on(s,t,e[t]);return s},za=(s,e)=>Ma(s,Ha(e));const Wa="ReactNative",qt={reactNative:"react-native",node:"node",browser:"browser",unknown:"unknown"};function qr(){return typeof Os<"u"&&typeof Os.versions<"u"&&typeof Os.versions.node<"u"}function xr(){return!Pi()&&!!cr()&&navigator.product===Wa}function Ur(){return!qr()&&!!cr()&&!!Pi()}function Ka(){return xr()?qt.reactNative:qr()?qt.node:Ur()?qt.browser:qt.unknown}function Ga(s){var e,t;const i=Ja();try{return s!=null&&s.url&&i.url&&new URL(s.url).host!==new URL(i.url).host&&(console.warn(`The configured WalletConnect 'metadata.url':${s.url} differs from the actual page url:${i.url}. This is probably unintended and can lead to issues.`),s.url=i.url),(e=s==null?void 0:s.icons)!=null&&e.length&&s.icons.length>0&&(s.icons=s.icons.filter(n=>n!=="")),za(an(an({},i),s),{url:(s==null?void 0:s.url)||i.url,name:(s==null?void 0:s.name)||i.name,description:(s==null?void 0:s.description)||i.description,icons:(t=s==null?void 0:s.icons)!=null&&t.length&&s.icons.length>0?s.icons:i.icons})}catch(n){return console.warn("Error populating app metadata",n),s||i}}function Ja(){return No()||{name:"",description:"",url:"",icons:[""]}}function ct(s,e){return s.filter(t=>e.includes(t)).length===s.length}function gt(s=F.FIVE_MINUTES,e){const t=F.toMiliseconds(s||F.FIVE_MINUTES);let i,n,r,o;return{resolve:a=>{r&&i&&(clearTimeout(r),i(a),o=Promise.resolve(a))},reject:a=>{r&&n&&(clearTimeout(r),n(a))},done:()=>new Promise((a,c)=>{if(o)return a(o);r=setTimeout(()=>{const l=new Error(e);o=Promise.reject(l),c(l)},t),i=a,n=c})}}function Ya(s){const[e,t]=s.split(":"),i={id:void 0,topic:void 0};if(e==="topic"&&typeof t=="string")i.topic=t;else if(e==="id"&&Number.isInteger(Number(t)))i.id=Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);return i}function we(s,e){return F.fromMiliseconds(Date.now()+F.toMiliseconds(s))}function wt(s){return Date.now()>=F.toMiliseconds(s)}function J(s,e){return`${s}${e?`:${e}`:""}`}function Ue(s=[],e=[]){return[...new Set([...s,...e])]}async function Za({id:s,topic:e,wcDeepLink:t}){var i;try{if(!t)return;const n=typeof t=="string"?JSON.parse(t):t,r=n==null?void 0:n.href;if(typeof r!="string")return;const o=Qa(r,s,e),a=Ka();if(a===qt.browser){if(!((i=Pi())!=null&&i.hasFocus())){console.warn("Document does not have focus, skipping deeplink.");return}Xa(o)}else a===qt.reactNative&&typeof(me==null?void 0:me.Linking)<"u"&&await me.Linking.openURL(o)}catch(n){console.error(n)}}function Qa(s,e,t){const i=`requestId=${e}&sessionTopic=${t}`;s.endsWith("/")&&(s=s.slice(0,-1));let n=`${s}`;if(s.startsWith("https://t.me")){const r=s.includes("?")?"&startapp=":"?startapp=";n=`${n}${r}${nc(i,!0)}`}else n=`${n}/wc?${i}`;return n}function Xa(s){let e="_self";ic()?e="_top":(sc()||s.startsWith("https://")||s.startsWith("http://"))&&(e="_blank"),window.open(s,e,"noreferrer noopener")}async function ec(s,e){let t="";try{if(Ur()&&(t=localStorage.getItem(e),t))return t;t=await s.getItem(e)}catch(i){console.error(i)}return t}function cn(s,e){if(!s.includes(e))return null;const t=s.split(/([&,?,=])/),i=t.indexOf(e);return t[i+2]}function tc(){return typeof Os<"u"&&La.IS_VITEST==="true"}function sc(){return typeof window<"u"&&(!!window.TelegramWebviewProxy||!!window.Telegram||!!window.TelegramWebviewProxyProto)}function ic(){try{return window.self!==window.top}catch{return!1}}function nc(s,e=!1){const t=We.from(s).toString("base64");return e?t.replace(/[=]/g,""):t}function $s(s){if(!Number.isSafeInteger(s)||s<0)throw new Error("positive integer expected, got "+s)}function rc(s){return s instanceof Uint8Array||ArrayBuffer.isView(s)&&s.constructor.name==="Uint8Array"}function us(s,...e){if(!rc(s))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(s.length))throw new Error("Uint8Array expected of length "+e+", got length="+s.length)}function oc(s){if(typeof s!="function"||typeof s.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");$s(s.outputLen),$s(s.blockLen)}function jt(s,e=!0){if(s.destroyed)throw new Error("Hash instance has been destroyed");if(e&&s.finished)throw new Error("Hash#digest() has already been called")}function Dr(s,e){us(s);const t=e.outputLen;if(s.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}const ys=BigInt(2**32-1),ln=BigInt(32);function ac(s,e=!1){return e?{h:Number(s&ys),l:Number(s>>ln&ys)}:{h:Number(s>>ln&ys)|0,l:Number(s&ys)|0}}function cc(s,e=!1){let t=new Uint32Array(s.length),i=new Uint32Array(s.length);for(let n=0;n<s.length;n++){const{h:r,l:o}=ac(s[n],e);[t[n],i[n]]=[r,o]}return[t,i]}const lc=(s,e,t)=>s<<t|e>>>32-t,hc=(s,e,t)=>e<<t|s>>>32-t,uc=(s,e,t)=>e<<t-32|s>>>64-t,dc=(s,e,t)=>s<<t-32|e>>>64-t,mt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function pc(s){return new Uint32Array(s.buffer,s.byteOffset,Math.floor(s.byteLength/4))}function Vs(s){return new DataView(s.buffer,s.byteOffset,s.byteLength)}function ke(s,e){return s<<32-e|s>>>e}const hn=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function fc(s){return s<<24&4278190080|s<<8&16711680|s>>>8&65280|s>>>24&255}function un(s){for(let e=0;e<s.length;e++)s[e]=fc(s[e])}function gc(s){if(typeof s!="string")throw new Error("utf8ToBytes expected string, got "+typeof s);return new Uint8Array(new TextEncoder().encode(s))}function xs(s){return typeof s=="string"&&(s=gc(s)),us(s),s}function wc(...s){let e=0;for(let i=0;i<s.length;i++){const n=s[i];us(n),e+=n.length}const t=new Uint8Array(e);for(let i=0,n=0;i<s.length;i++){const r=s[i];t.set(r,n),n+=r.length}return t}let _i=class{clone(){return this._cloneInto()}};function Lr(s){const e=i=>s().update(xs(i)).digest(),t=s();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>s(),e}function jr(s=32){if(mt&&typeof mt.getRandomValues=="function")return mt.getRandomValues(new Uint8Array(s));if(mt&&typeof mt.randomBytes=="function")return mt.randomBytes(s);throw new Error("crypto.getRandomValues must be defined")}const Br=[],Mr=[],Hr=[],mc=BigInt(0),ss=BigInt(1),yc=BigInt(2),vc=BigInt(7),Ec=BigInt(256),bc=BigInt(113);for(let s=0,e=ss,t=1,i=0;s<24;s++){[t,i]=[i,(2*t+3*i)%5],Br.push(2*(5*i+t)),Mr.push((s+1)*(s+2)/2%64);let n=mc;for(let r=0;r<7;r++)e=(e<<ss^(e>>vc)*bc)%Ec,e&yc&&(n^=ss<<(ss<<BigInt(r))-ss);Hr.push(n)}const[Ic,Cc]=cc(Hr,!0),dn=(s,e,t)=>t>32?uc(s,e,t):lc(s,e,t),pn=(s,e,t)=>t>32?dc(s,e,t):hc(s,e,t);function Ac(s,e=24){const t=new Uint32Array(10);for(let i=24-e;i<24;i++){for(let o=0;o<10;o++)t[o]=s[o]^s[o+10]^s[o+20]^s[o+30]^s[o+40];for(let o=0;o<10;o+=2){const a=(o+8)%10,c=(o+2)%10,l=t[c],h=t[c+1],u=dn(l,h,1)^t[a],d=pn(l,h,1)^t[a+1];for(let f=0;f<50;f+=10)s[o+f]^=u,s[o+f+1]^=d}let n=s[2],r=s[3];for(let o=0;o<24;o++){const a=Mr[o],c=dn(n,r,a),l=pn(n,r,a),h=Br[o];n=s[h],r=s[h+1],s[h]=c,s[h+1]=l}for(let o=0;o<50;o+=10){for(let a=0;a<10;a++)t[a]=s[o+a];for(let a=0;a<10;a++)s[o+a]^=~t[(a+2)%10]&t[(a+4)%10]}s[0]^=Ic[i],s[1]^=Cc[i]}t.fill(0)}class Ti extends _i{constructor(e,t,i,n=!1,r=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=i,this.enableXOF=n,this.rounds=r,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,$s(i),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=pc(this.state)}keccak(){hn||un(this.state32),Ac(this.state32,this.rounds),hn||un(this.state32),this.posOut=0,this.pos=0}update(e){jt(this);const{blockLen:t,state:i}=this;e=xs(e);const n=e.length;for(let r=0;r<n;){const o=Math.min(t-this.pos,n-r);for(let a=0;a<o;a++)i[this.pos++]^=e[r++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:i,blockLen:n}=this;e[i]^=t,t&128&&i===n-1&&this.keccak(),e[n-1]^=128,this.keccak()}writeInto(e){jt(this,!1),us(e),this.finish();const t=this.state,{blockLen:i}=this;for(let n=0,r=e.length;n<r;){this.posOut>=i&&this.keccak();const o=Math.min(i-this.posOut,r-n);e.set(t.subarray(this.posOut,this.posOut+o),n),this.posOut+=o,n+=o}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return $s(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(Dr(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:i,outputLen:n,rounds:r,enableXOF:o}=this;return e||(e=new Ti(t,i,n,o,r)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=r,e.suffix=i,e.outputLen=n,e.enableXOF=o,e.destroyed=this.destroyed,e}}const Nc=(s,e,t)=>Lr(()=>new Ti(e,s,t)),Pc=Nc(1,136,256/8),Sc="https://rpc.walletconnect.org/v1";function Fr(s){const e=`Ethereum Signed Message:
${s.length}`,t=new TextEncoder().encode(e+s);return"0x"+We.from(Pc(t)).toString("hex")}async function Oc(s,e,t,i,n,r){switch(t.t){case"eip191":return await _c(s,e,t.s);case"eip1271":return await Tc(s,e,t.s,i,n,r);default:throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`)}}async function _c(s,e,t){return(await Ua({hash:Fr(e),signature:t})).toLowerCase()===s.toLowerCase()}async function Tc(s,e,t,i,n,r){const o=Lt(i);if(!o.namespace||!o.reference)throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${i}`);try{const a="0x1626ba7e",c="0000000000000000000000000000000000000000000000000000000000000040",l="0000000000000000000000000000000000000000000000000000000000000041",h=t.substring(2),u=Fr(e).substring(2),d=a+u+c+l+h,f=await fetch(`${r||Sc}/?chainId=${i}&projectId=${n}`,{method:"POST",body:JSON.stringify({id:Rc(),jsonrpc:"2.0",method:"eth_call",params:[{to:s,data:d},"latest"]})}),{result:y}=await f.json();return y?y.slice(0,a.length).toLowerCase()===a.toLowerCase():!1}catch(a){return console.error("isValidEip1271Signature: ",a),!1}}function Rc(){return Date.now()+Math.floor(Math.random()*1e3)}function $c(s){const e=atob(s),t=new Uint8Array(e.length);for(let o=0;o<e.length;o++)t[o]=e.charCodeAt(o);const i=t[0];if(i===0)throw new Error("No signatures found");const n=1+i*64;if(t.length<n)throw new Error("Transaction data too short for claimed signature count");if(t.length<100)throw new Error("Transaction too short");const r=We.from(s,"base64").slice(1,65);return lr.encode(r)}var kc=Object.defineProperty,qc=Object.defineProperties,xc=Object.getOwnPropertyDescriptors,fn=Object.getOwnPropertySymbols,Uc=Object.prototype.hasOwnProperty,Dc=Object.prototype.propertyIsEnumerable,gn=(s,e,t)=>e in s?kc(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,Lc=(s,e)=>{for(var t in e||(e={}))Uc.call(e,t)&&gn(s,t,e[t]);if(fn)for(var t of fn(e))Dc.call(e,t)&&gn(s,t,e[t]);return s},jc=(s,e)=>qc(s,xc(e));const Bc="did:pkh:",Ri=s=>s==null?void 0:s.split(":"),Mc=s=>{const e=s&&Ri(s);if(e)return s.includes(Bc)?e[3]:e[1]},pi=s=>{const e=s&&Ri(s);if(e)return e[2]+":"+e[3]},ks=s=>{const e=s&&Ri(s);if(e)return e.pop()};async function wn(s){const{cacao:e,projectId:t}=s,{s:i,p:n}=e,r=Vr(n,n.iss),o=ks(n.iss);return await Oc(o,r,i,pi(n.iss),t)}const Vr=(s,e)=>{const t=`${s.domain} wants you to sign in with your Ethereum account:`,i=ks(e);if(!s.aud&&!s.uri)throw new Error("Either `aud` or `uri` is required to construct the message");let n=s.statement||void 0;const r=`URI: ${s.aud||s.uri}`,o=`Version: ${s.version}`,a=`Chain ID: ${Mc(e)}`,c=`Nonce: ${s.nonce}`,l=`Issued At: ${s.iat}`,h=s.exp?`Expiration Time: ${s.exp}`:void 0,u=s.nbf?`Not Before: ${s.nbf}`:void 0,d=s.requestId?`Request ID: ${s.requestId}`:void 0,f=s.resources?`Resources:${s.resources.map(w=>`
- ${w}`).join("")}`:void 0,y=_s(s.resources);if(y){const w=cs(y);n=Yc(n,w)}return[t,i,"",n,"",r,o,a,c,l,h,u,d,f].filter(w=>w!=null).join(`
`)};function Hc(s){return We.from(JSON.stringify(s)).toString("base64")}function Fc(s){return JSON.parse(We.from(s,"base64").toString("utf-8"))}function ut(s){if(!s)throw new Error("No recap provided, value is undefined");if(!s.att)throw new Error("No `att` property found");const e=Object.keys(s.att);if(!(e!=null&&e.length))throw new Error("No resources found in `att` property");e.forEach(t=>{const i=s.att[t];if(Array.isArray(i))throw new Error(`Resource must be an object: ${t}`);if(typeof i!="object")throw new Error(`Resource must be an object: ${t}`);if(!Object.keys(i).length)throw new Error(`Resource object is empty: ${t}`);Object.keys(i).forEach(n=>{const r=i[n];if(!Array.isArray(r))throw new Error(`Ability limits ${n} must be an array of objects, found: ${r}`);if(!r.length)throw new Error(`Value of ${n} is empty array, must be an array with objects`);r.forEach(o=>{if(typeof o!="object")throw new Error(`Ability limits (${n}) must be an array of objects, found: ${o}`)})})})}function Vc(s,e,t,i={}){return t==null||t.sort((n,r)=>n.localeCompare(r)),{att:{[s]:zc(e,t,i)}}}function zc(s,e,t={}){e=e==null?void 0:e.sort((n,r)=>n.localeCompare(r));const i=e.map(n=>({[`${s}/${n}`]:[t]}));return Object.assign({},...i)}function zr(s){return ut(s),`urn:recap:${Hc(s).replace(/=/g,"")}`}function cs(s){const e=Fc(s.replace("urn:recap:",""));return ut(e),e}function Wc(s,e,t){const i=Vc(s,e,t);return zr(i)}function Kc(s){return s&&s.includes("urn:recap:")}function Gc(s,e){const t=cs(s),i=cs(e),n=Jc(t,i);return zr(n)}function Jc(s,e){ut(s),ut(e);const t=Object.keys(s.att).concat(Object.keys(e.att)).sort((n,r)=>n.localeCompare(r)),i={att:{}};return t.forEach(n=>{var r,o;Object.keys(((r=s.att)==null?void 0:r[n])||{}).concat(Object.keys(((o=e.att)==null?void 0:o[n])||{})).sort((a,c)=>a.localeCompare(c)).forEach(a=>{var c,l;i.att[n]=jc(Lc({},i.att[n]),{[a]:((c=s.att[n])==null?void 0:c[a])||((l=e.att[n])==null?void 0:l[a])})})}),i}function Yc(s="",e){ut(e);const t="I further authorize the stated URI to perform the following actions on my behalf: ";if(s.includes(t))return s;const i=[];let n=0;Object.keys(e.att).forEach(a=>{const c=Object.keys(e.att[a]).map(u=>({ability:u.split("/")[0],action:u.split("/")[1]}));c.sort((u,d)=>u.action.localeCompare(d.action));const l={};c.forEach(u=>{l[u.ability]||(l[u.ability]=[]),l[u.ability].push(u.action)});const h=Object.keys(l).map(u=>(n++,`(${n}) '${u}': '${l[u].join("', '")}' for '${a}'.`));i.push(h.join(", ").replace(".,","."))});const r=i.join(" "),o=`${t}${r}`;return`${s?s+" ":""}${o}`}function mn(s){var e;const t=cs(s);ut(t);const i=(e=t.att)==null?void 0:e.eip155;return i?Object.keys(i).map(n=>n.split("/")[1]):[]}function yn(s){const e=cs(s);ut(e);const t=[];return Object.values(e.att).forEach(i=>{Object.values(i).forEach(n=>{var r;(r=n==null?void 0:n[0])!=null&&r.chains&&t.push(n[0].chains)})}),[...new Set(t.flat())]}function _s(s){if(!s)return;const e=s==null?void 0:s[s.length-1];return Kc(e)?e:void 0}function zs(s){if(!Number.isSafeInteger(s)||s<0)throw new Error("positive integer expected, got "+s)}function Wr(s){return s instanceof Uint8Array||ArrayBuffer.isView(s)&&s.constructor.name==="Uint8Array"}function Ie(s,...e){if(!Wr(s))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(s.length))throw new Error("Uint8Array expected of length "+e+", got length="+s.length)}function vn(s,e=!0){if(s.destroyed)throw new Error("Hash instance has been destroyed");if(e&&s.finished)throw new Error("Hash#digest() has already been called")}function Zc(s,e){Ie(s);const t=e.outputLen;if(s.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function En(s){if(typeof s!="boolean")throw new Error(`boolean expected, not ${s}`)}const Xe=s=>new Uint32Array(s.buffer,s.byteOffset,Math.floor(s.byteLength/4)),Qc=s=>new DataView(s.buffer,s.byteOffset,s.byteLength),Xc=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Xc)throw new Error("Non little-endian hardware is not supported");function el(s){if(typeof s!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(s))}function fi(s){if(typeof s=="string")s=el(s);else if(Wr(s))s=gi(s);else throw new Error("Uint8Array expected, got "+typeof s);return s}function tl(s,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(s,e)}function sl(s,e){if(s.length!==e.length)return!1;let t=0;for(let i=0;i<s.length;i++)t|=s[i]^e[i];return t===0}const il=(s,e)=>{function t(i,...n){if(Ie(i),s.nonceLength!==void 0){const l=n[0];if(!l)throw new Error("nonce / iv required");s.varSizeNonce?Ie(l):Ie(l,s.nonceLength)}const r=s.tagLength;r&&n[1]!==void 0&&Ie(n[1]);const o=e(i,...n),a=(l,h)=>{if(h!==void 0){if(l!==2)throw new Error("cipher output not supported");Ie(h)}};let c=!1;return{encrypt(l,h){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,Ie(l),a(o.encrypt.length,h),o.encrypt(l,h)},decrypt(l,h){if(Ie(l),r&&l.length<r)throw new Error("invalid ciphertext length: smaller than tagLength="+r);return a(o.decrypt.length,h),o.decrypt(l,h)}}}return Object.assign(t,s),t};function bn(s,e,t=!0){if(e===void 0)return new Uint8Array(s);if(e.length!==s)throw new Error("invalid output length, expected "+s+", got: "+e.length);if(t&&!nl(e))throw new Error("invalid output, must be aligned");return e}function In(s,e,t,i){if(typeof s.setBigUint64=="function")return s.setBigUint64(e,t,i);const n=BigInt(32),r=BigInt(4294967295),o=Number(t>>n&r),a=Number(t&r);s.setUint32(e+4,o,i),s.setUint32(e+0,a,i)}function nl(s){return s.byteOffset%4===0}function gi(s){return Uint8Array.from(s)}function Bt(...s){for(let e=0;e<s.length;e++)s[e].fill(0)}const Kr=s=>Uint8Array.from(s.split("").map(e=>e.charCodeAt(0))),rl=Kr("expand 16-byte k"),ol=Kr("expand 32-byte k"),al=Xe(rl),cl=Xe(ol);function W(s,e){return s<<e|s>>>32-e}function wi(s){return s.byteOffset%4===0}const vs=64,ll=16,Gr=2**32-1,Cn=new Uint32Array;function hl(s,e,t,i,n,r,o,a){const c=n.length,l=new Uint8Array(vs),h=Xe(l),u=wi(n)&&wi(r),d=u?Xe(n):Cn,f=u?Xe(r):Cn;for(let y=0;y<c;o++){if(s(e,t,i,h,o,a),o>=Gr)throw new Error("arx: counter overflow");const w=Math.min(vs,c-y);if(u&&w===vs){const p=y/4;if(y%4!==0)throw new Error("arx: invalid block position");for(let m=0,g;m<ll;m++)g=p+m,f[g]=d[g]^h[m];y+=vs;continue}for(let p=0,m;p<w;p++)m=y+p,r[m]=n[m]^l[p];y+=w}}function ul(s,e){const{allowShortKeys:t,extendNonceFn:i,counterLength:n,counterRight:r,rounds:o}=tl({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof s!="function")throw new Error("core must be a function");return zs(n),zs(o),En(r),En(t),(a,c,l,h,u=0)=>{Ie(a),Ie(c),Ie(l);const d=l.length;if(h===void 0&&(h=new Uint8Array(d)),Ie(h),zs(u),u<0||u>=Gr)throw new Error("arx: counter overflow");if(h.length<d)throw new Error(`arx: output (${h.length}) is shorter than data (${d})`);const f=[];let y=a.length,w,p;if(y===32)f.push(w=gi(a)),p=cl;else if(y===16&&t)w=new Uint8Array(32),w.set(a),w.set(a,16),p=al,f.push(w);else throw new Error(`arx: invalid 32-byte key, got length=${y}`);wi(c)||f.push(c=gi(c));const m=Xe(w);if(i){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");i(p,m,Xe(c.subarray(0,16)),m),c=c.subarray(16)}const g=16-n;if(g!==c.length)throw new Error(`arx: nonce must be ${g} or 16 bytes`);if(g!==12){const _=new Uint8Array(12);_.set(c,r?0:12-c.length),c=_,f.push(c)}const I=Xe(c);return hl(s,p,m,I,l,h,u,o),Bt(...f),h}}const de=(s,e)=>s[e++]&255|(s[e++]&255)<<8;class dl{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=fi(e),Ie(e,32);const t=de(e,0),i=de(e,2),n=de(e,4),r=de(e,6),o=de(e,8),a=de(e,10),c=de(e,12),l=de(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|i<<3)&8191,this.r[2]=(i>>>10|n<<6)&7939,this.r[3]=(n>>>7|r<<9)&8191,this.r[4]=(r>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|l<<8)&8191,this.r[9]=l>>>5&127;for(let h=0;h<8;h++)this.pad[h]=de(e,16+2*h)}process(e,t,i=!1){const n=i?0:2048,{h:r,r:o}=this,a=o[0],c=o[1],l=o[2],h=o[3],u=o[4],d=o[5],f=o[6],y=o[7],w=o[8],p=o[9],m=de(e,t+0),g=de(e,t+2),I=de(e,t+4),_=de(e,t+6),T=de(e,t+8),P=de(e,t+10),O=de(e,t+12),$=de(e,t+14);let b=r[0]+(m&8191),L=r[1]+((m>>>13|g<<3)&8191),k=r[2]+((g>>>10|I<<6)&8191),x=r[3]+((I>>>7|_<<9)&8191),B=r[4]+((_>>>4|T<<12)&8191),E=r[5]+(T>>>1&8191),N=r[6]+((T>>>14|P<<2)&8191),A=r[7]+((P>>>11|O<<5)&8191),R=r[8]+((O>>>8|$<<8)&8191),q=r[9]+($>>>5|n),C=0,j=C+b*a+L*(5*p)+k*(5*w)+x*(5*y)+B*(5*f);C=j>>>13,j&=8191,j+=E*(5*d)+N*(5*u)+A*(5*h)+R*(5*l)+q*(5*c),C+=j>>>13,j&=8191;let M=C+b*c+L*a+k*(5*p)+x*(5*w)+B*(5*y);C=M>>>13,M&=8191,M+=E*(5*f)+N*(5*d)+A*(5*u)+R*(5*h)+q*(5*l),C+=M>>>13,M&=8191;let H=C+b*l+L*c+k*a+x*(5*p)+B*(5*w);C=H>>>13,H&=8191,H+=E*(5*y)+N*(5*f)+A*(5*d)+R*(5*u)+q*(5*h),C+=H>>>13,H&=8191;let Z=C+b*h+L*l+k*c+x*a+B*(5*p);C=Z>>>13,Z&=8191,Z+=E*(5*w)+N*(5*y)+A*(5*f)+R*(5*d)+q*(5*u),C+=Z>>>13,Z&=8191;let G=C+b*u+L*h+k*l+x*c+B*a;C=G>>>13,G&=8191,G+=E*(5*p)+N*(5*w)+A*(5*y)+R*(5*f)+q*(5*d),C+=G>>>13,G&=8191;let ie=C+b*d+L*u+k*h+x*l+B*c;C=ie>>>13,ie&=8191,ie+=E*a+N*(5*p)+A*(5*w)+R*(5*y)+q*(5*f),C+=ie>>>13,ie&=8191;let ae=C+b*f+L*d+k*u+x*h+B*l;C=ae>>>13,ae&=8191,ae+=E*c+N*a+A*(5*p)+R*(5*w)+q*(5*y),C+=ae>>>13,ae&=8191;let pe=C+b*y+L*f+k*d+x*u+B*h;C=pe>>>13,pe&=8191,pe+=E*l+N*c+A*a+R*(5*p)+q*(5*w),C+=pe>>>13,pe&=8191;let ne=C+b*w+L*y+k*f+x*d+B*u;C=ne>>>13,ne&=8191,ne+=E*h+N*l+A*c+R*a+q*(5*p),C+=ne>>>13,ne&=8191;let re=C+b*p+L*w+k*y+x*f+B*d;C=re>>>13,re&=8191,re+=E*u+N*h+A*l+R*c+q*a,C+=re>>>13,re&=8191,C=(C<<2)+C|0,C=C+j|0,j=C&8191,C=C>>>13,M+=C,r[0]=j,r[1]=M,r[2]=H,r[3]=Z,r[4]=G,r[5]=ie,r[6]=ae,r[7]=pe,r[8]=ne,r[9]=re}finalize(){const{h:e,pad:t}=this,i=new Uint16Array(10);let n=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=n,n=e[a]>>>13,e[a]&=8191;e[0]+=n*5,n=e[0]>>>13,e[0]&=8191,e[1]+=n,n=e[1]>>>13,e[1]&=8191,e[2]+=n,i[0]=e[0]+5,n=i[0]>>>13,i[0]&=8191;for(let a=1;a<10;a++)i[a]=e[a]+n,n=i[a]>>>13,i[a]&=8191;i[9]-=8192;let r=(n^1)-1;for(let a=0;a<10;a++)i[a]&=r;r=~r;for(let a=0;a<10;a++)e[a]=e[a]&r|i[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535;Bt(i)}update(e){vn(this);const{buffer:t,blockLen:i}=this;e=fi(e);const n=e.length;for(let r=0;r<n;){const o=Math.min(i-this.pos,n-r);if(o===i){for(;i<=n-r;r+=i)this.process(e,r);continue}t.set(e.subarray(r,r+o),this.pos),this.pos+=o,r+=o,this.pos===i&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){Bt(this.h,this.r,this.buffer,this.pad)}digestInto(e){vn(this),Zc(e,this),this.finished=!0;const{buffer:t,h:i}=this;let{pos:n}=this;if(n){for(t[n++]=1;n<16;n++)t[n]=0;this.process(t,0,!0)}this.finalize();let r=0;for(let o=0;o<8;o++)e[r++]=i[o]>>>0,e[r++]=i[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const i=e.slice(0,t);return this.destroy(),i}}function pl(s){const e=(i,n)=>s(n).update(fi(i)).digest(),t=s(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=i=>s(i),e}const fl=pl(s=>new dl(s));function gl(s,e,t,i,n,r=20){let o=s[0],a=s[1],c=s[2],l=s[3],h=e[0],u=e[1],d=e[2],f=e[3],y=e[4],w=e[5],p=e[6],m=e[7],g=n,I=t[0],_=t[1],T=t[2],P=o,O=a,$=c,b=l,L=h,k=u,x=d,B=f,E=y,N=w,A=p,R=m,q=g,C=I,j=_,M=T;for(let Z=0;Z<r;Z+=2)P=P+L|0,q=W(q^P,16),E=E+q|0,L=W(L^E,12),P=P+L|0,q=W(q^P,8),E=E+q|0,L=W(L^E,7),O=O+k|0,C=W(C^O,16),N=N+C|0,k=W(k^N,12),O=O+k|0,C=W(C^O,8),N=N+C|0,k=W(k^N,7),$=$+x|0,j=W(j^$,16),A=A+j|0,x=W(x^A,12),$=$+x|0,j=W(j^$,8),A=A+j|0,x=W(x^A,7),b=b+B|0,M=W(M^b,16),R=R+M|0,B=W(B^R,12),b=b+B|0,M=W(M^b,8),R=R+M|0,B=W(B^R,7),P=P+k|0,M=W(M^P,16),A=A+M|0,k=W(k^A,12),P=P+k|0,M=W(M^P,8),A=A+M|0,k=W(k^A,7),O=O+x|0,q=W(q^O,16),R=R+q|0,x=W(x^R,12),O=O+x|0,q=W(q^O,8),R=R+q|0,x=W(x^R,7),$=$+B|0,C=W(C^$,16),E=E+C|0,B=W(B^E,12),$=$+B|0,C=W(C^$,8),E=E+C|0,B=W(B^E,7),b=b+L|0,j=W(j^b,16),N=N+j|0,L=W(L^N,12),b=b+L|0,j=W(j^b,8),N=N+j|0,L=W(L^N,7);let H=0;i[H++]=o+P|0,i[H++]=a+O|0,i[H++]=c+$|0,i[H++]=l+b|0,i[H++]=h+L|0,i[H++]=u+k|0,i[H++]=d+x|0,i[H++]=f+B|0,i[H++]=y+E|0,i[H++]=w+N|0,i[H++]=p+A|0,i[H++]=m+R|0,i[H++]=g+q|0,i[H++]=I+C|0,i[H++]=_+j|0,i[H++]=T+M|0}const wl=ul(gl,{counterRight:!1,counterLength:4,allowShortKeys:!1}),ml=new Uint8Array(16),An=(s,e)=>{s.update(e);const t=e.length%16;t&&s.update(ml.subarray(t))},yl=new Uint8Array(32);function Nn(s,e,t,i,n){const r=s(e,t,yl),o=fl.create(r);n&&An(o,n),An(o,i);const a=new Uint8Array(16),c=Qc(a);In(c,0,BigInt(n?n.length:0),!0),In(c,8,BigInt(i.length),!0),o.update(a);const l=o.digest();return Bt(r,a),l}const vl=s=>(e,t,i)=>({encrypt(n,r){const o=n.length;r=bn(o+16,r,!1),r.set(n);const a=r.subarray(0,-16);s(e,t,a,a,1);const c=Nn(s,e,t,a,i);return r.set(c,o),Bt(c),r},decrypt(n,r){r=bn(n.length-16,r,!1);const o=n.subarray(0,-16),a=n.subarray(-16),c=Nn(s,e,t,o,i);if(!sl(a,c))throw new Error("invalid tag");return r.set(n.subarray(0,-16)),s(e,t,r,r,1),Bt(c),r}});il({blockSize:64,nonceLength:12,tagLength:16},vl(wl));class Jr extends _i{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,oc(e);const i=xs(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,r=new Uint8Array(n);r.set(i.length>n?e.create().update(i).digest():i);for(let o=0;o<r.length;o++)r[o]^=54;this.iHash.update(r),this.oHash=e.create();for(let o=0;o<r.length;o++)r[o]^=106;this.oHash.update(r),r.fill(0)}update(e){return jt(this),this.iHash.update(e),this}digestInto(e){jt(this),us(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:i,finished:n,destroyed:r,blockLen:o,outputLen:a}=this;return e=e,e.finished=n,e.destroyed=r,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=i._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Yr=(s,e,t)=>new Jr(s,e).update(t).digest();Yr.create=(s,e)=>new Jr(s,e);function El(s,e,t,i){if(typeof s.setBigUint64=="function")return s.setBigUint64(e,t,i);const n=BigInt(32),r=BigInt(4294967295),o=Number(t>>n&r),a=Number(t&r),c=i?4:0,l=i?0:4;s.setUint32(e+c,o,i),s.setUint32(e+l,a,i)}function bl(s,e,t){return s&e^~s&t}function Il(s,e,t){return s&e^s&t^e&t}let Cl=class extends _i{constructor(e,t,i,n){super(),this.blockLen=e,this.outputLen=t,this.padOffset=i,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Vs(this.buffer)}update(e){jt(this);const{view:t,buffer:i,blockLen:n}=this;e=xs(e);const r=e.length;for(let o=0;o<r;){const a=Math.min(n-this.pos,r-o);if(a===n){const c=Vs(e);for(;n<=r-o;o+=n)this.process(c,o);continue}i.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===n&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){jt(this),Dr(e,this),this.finished=!0;const{buffer:t,view:i,blockLen:n,isLE:r}=this;let{pos:o}=this;t[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>n-o&&(this.process(i,0),o=0);for(let u=o;u<n;u++)t[u]=0;El(i,n-8,BigInt(this.length*8),r),this.process(i,0);const a=Vs(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,h=this.get();if(l>h.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<l;u++)a.setUint32(4*u,h[u],r)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const i=e.slice(0,t);return this.destroy(),i}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:i,length:n,finished:r,destroyed:o,pos:a}=this;return e.length=n,e.pos=a,e.finished=r,e.destroyed=o,n%t&&e.buffer.set(i),e}};const Al=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Ze=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Qe=new Uint32Array(64);class Nl extends Cl{constructor(){super(64,32,8,!1),this.A=Ze[0]|0,this.B=Ze[1]|0,this.C=Ze[2]|0,this.D=Ze[3]|0,this.E=Ze[4]|0,this.F=Ze[5]|0,this.G=Ze[6]|0,this.H=Ze[7]|0}get(){const{A:e,B:t,C:i,D:n,E:r,F:o,G:a,H:c}=this;return[e,t,i,n,r,o,a,c]}set(e,t,i,n,r,o,a,c){this.A=e|0,this.B=t|0,this.C=i|0,this.D=n|0,this.E=r|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let u=0;u<16;u++,t+=4)Qe[u]=e.getUint32(t,!1);for(let u=16;u<64;u++){const d=Qe[u-15],f=Qe[u-2],y=ke(d,7)^ke(d,18)^d>>>3,w=ke(f,17)^ke(f,19)^f>>>10;Qe[u]=w+Qe[u-7]+y+Qe[u-16]|0}let{A:i,B:n,C:r,D:o,E:a,F:c,G:l,H:h}=this;for(let u=0;u<64;u++){const d=ke(a,6)^ke(a,11)^ke(a,25),f=h+d+bl(a,c,l)+Al[u]+Qe[u]|0,y=(ke(i,2)^ke(i,13)^ke(i,22))+Il(i,n,r)|0;h=l,l=c,c=a,a=o+f|0,o=r,r=n,n=i,i=f+y|0}i=i+this.A|0,n=n+this.B|0,r=r+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,h=h+this.H|0,this.set(i,n,r,o,a,c,l,h)}roundClean(){Qe.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const $i=Lr(()=>new Nl);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Us=BigInt(0),Ds=BigInt(1),Pl=BigInt(2);function dt(s){return s instanceof Uint8Array||ArrayBuffer.isView(s)&&s.constructor.name==="Uint8Array"}function ds(s){if(!dt(s))throw new Error("Uint8Array expected")}function Mt(s,e){if(typeof e!="boolean")throw new Error(s+" boolean expected, got "+e)}const Sl=Array.from({length:256},(s,e)=>e.toString(16).padStart(2,"0"));function Ht(s){ds(s);let e="";for(let t=0;t<s.length;t++)e+=Sl[s[t]];return e}function xt(s){const e=s.toString(16);return e.length&1?"0"+e:e}function ki(s){if(typeof s!="string")throw new Error("hex string expected, got "+typeof s);return s===""?Us:BigInt("0x"+s)}const He={_0:48,_9:57,A:65,F:70,a:97,f:102};function Pn(s){if(s>=He._0&&s<=He._9)return s-He._0;if(s>=He.A&&s<=He.F)return s-(He.A-10);if(s>=He.a&&s<=He.f)return s-(He.a-10)}function Ft(s){if(typeof s!="string")throw new Error("hex string expected, got "+typeof s);const e=s.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const i=new Uint8Array(t);for(let n=0,r=0;n<t;n++,r+=2){const o=Pn(s.charCodeAt(r)),a=Pn(s.charCodeAt(r+1));if(o===void 0||a===void 0){const c=s[r]+s[r+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+r)}i[n]=o*16+a}return i}function lt(s){return ki(Ht(s))}function ls(s){return ds(s),ki(Ht(Uint8Array.from(s).reverse()))}function Vt(s,e){return Ft(s.toString(16).padStart(e*2,"0"))}function Ls(s,e){return Vt(s,e).reverse()}function Ol(s){return Ft(xt(s))}function be(s,e,t){let i;if(typeof e=="string")try{i=Ft(e)}catch(r){throw new Error(s+" must be hex string or Uint8Array, cause: "+r)}else if(dt(e))i=Uint8Array.from(e);else throw new Error(s+" must be hex string or Uint8Array");const n=i.length;if(typeof t=="number"&&n!==t)throw new Error(s+" of length "+t+" expected, got "+n);return i}function hs(...s){let e=0;for(let i=0;i<s.length;i++){const n=s[i];ds(n),e+=n.length}const t=new Uint8Array(e);for(let i=0,n=0;i<s.length;i++){const r=s[i];t.set(r,n),n+=r.length}return t}function _l(s,e){if(s.length!==e.length)return!1;let t=0;for(let i=0;i<s.length;i++)t|=s[i]^e[i];return t===0}function Tl(s){if(typeof s!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(s))}const Ws=s=>typeof s=="bigint"&&Us<=s;function js(s,e,t){return Ws(s)&&Ws(e)&&Ws(t)&&e<=s&&s<t}function ze(s,e,t,i){if(!js(e,t,i))throw new Error("expected valid "+s+": "+t+" <= n < "+i+", got "+e)}function Zr(s){let e;for(e=0;s>Us;s>>=Ds,e+=1);return e}function Rl(s,e){return s>>BigInt(e)&Ds}function $l(s,e,t){return s|(t?Ds:Us)<<BigInt(e)}const qi=s=>(Pl<<BigInt(s-1))-Ds,Ks=s=>new Uint8Array(s),Sn=s=>Uint8Array.from(s);function Qr(s,e,t){if(typeof s!="number"||s<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let i=Ks(s),n=Ks(s),r=0;const o=()=>{i.fill(1),n.fill(0),r=0},a=(...h)=>t(n,i,...h),c=(h=Ks())=>{n=a(Sn([0]),h),i=a(),h.length!==0&&(n=a(Sn([1]),h),i=a())},l=()=>{if(r++>=1e3)throw new Error("drbg: tried 1000 values");let h=0;const u=[];for(;h<e;){i=a();const d=i.slice();u.push(d),h+=i.length}return hs(...u)};return(h,u)=>{o(),c(h);let d;for(;!(d=u(l()));)c();return o(),d}}const kl={bigint:s=>typeof s=="bigint",function:s=>typeof s=="function",boolean:s=>typeof s=="boolean",string:s=>typeof s=="string",stringOrUint8Array:s=>typeof s=="string"||dt(s),isSafeInteger:s=>Number.isSafeInteger(s),array:s=>Array.isArray(s),field:(s,e)=>e.Fp.isValid(s),hash:s=>typeof s=="function"&&Number.isSafeInteger(s.outputLen)};function Gt(s,e,t={}){const i=(n,r,o)=>{const a=kl[r];if(typeof a!="function")throw new Error("invalid validator function");const c=s[n];if(!(o&&c===void 0)&&!a(c,s))throw new Error("param "+String(n)+" is invalid. Expected "+r+", got "+c)};for(const[n,r]of Object.entries(e))i(n,r,!1);for(const[n,r]of Object.entries(t))i(n,r,!0);return s}const ql=()=>{throw new Error("not implemented")};function mi(s){const e=new WeakMap;return(t,...i)=>{const n=e.get(t);if(n!==void 0)return n;const r=s(t,...i);return e.set(t,r),r}}var xl=Object.freeze({__proto__:null,isBytes:dt,abytes:ds,abool:Mt,bytesToHex:Ht,numberToHexUnpadded:xt,hexToNumber:ki,hexToBytes:Ft,bytesToNumberBE:lt,bytesToNumberLE:ls,numberToBytesBE:Vt,numberToBytesLE:Ls,numberToVarBytesBE:Ol,ensureBytes:be,concatBytes:hs,equalBytes:_l,utf8ToBytes:Tl,inRange:js,aInRange:ze,bitLen:Zr,bitGet:Rl,bitSet:$l,bitMask:qi,createHmacDrbg:Qr,validateObject:Gt,notImplemented:ql,memoized:mi});const ue=BigInt(0),se=BigInt(1),ot=BigInt(2),Ul=BigInt(3),yi=BigInt(4),On=BigInt(5),_n=BigInt(8);function ve(s,e){const t=s%e;return t>=ue?t:e+t}function Xr(s,e,t){if(e<ue)throw new Error("invalid exponent, negatives unsupported");if(t<=ue)throw new Error("invalid modulus");if(t===se)return ue;let i=se;for(;e>ue;)e&se&&(i=i*s%t),s=s*s%t,e>>=se;return i}function _e(s,e,t){let i=s;for(;e-- >ue;)i*=i,i%=t;return i}function vi(s,e){if(s===ue)throw new Error("invert: expected non-zero number");if(e<=ue)throw new Error("invert: expected positive modulus, got "+e);let t=ve(s,e),i=e,n=ue,r=se;for(;t!==ue;){const o=i/t,a=i%t,c=n-r*o;i=t,t=a,n=r,r=c}if(i!==se)throw new Error("invert: does not exist");return ve(n,e)}function Dl(s){const e=(s-se)/ot;let t,i,n;for(t=s-se,i=0;t%ot===ue;t/=ot,i++);for(n=ot;n<s&&Xr(n,e,s)!==s-se;n++)if(n>1e3)throw new Error("Cannot find square root: likely non-prime P");if(i===1){const o=(s+se)/yi;return function(a,c){const l=a.pow(c,o);if(!a.eql(a.sqr(l),c))throw new Error("Cannot find square root");return l}}const r=(t+se)/ot;return function(o,a){if(o.pow(a,e)===o.neg(o.ONE))throw new Error("Cannot find square root");let c=i,l=o.pow(o.mul(o.ONE,n),t),h=o.pow(a,r),u=o.pow(a,t);for(;!o.eql(u,o.ONE);){if(o.eql(u,o.ZERO))return o.ZERO;let d=1;for(let y=o.sqr(u);d<c&&!o.eql(y,o.ONE);d++)y=o.sqr(y);const f=o.pow(l,se<<BigInt(c-d-1));l=o.sqr(f),h=o.mul(h,f),u=o.mul(u,l),c=d}return h}}function Ll(s){if(s%yi===Ul){const e=(s+se)/yi;return function(t,i){const n=t.pow(i,e);if(!t.eql(t.sqr(n),i))throw new Error("Cannot find square root");return n}}if(s%_n===On){const e=(s-On)/_n;return function(t,i){const n=t.mul(i,ot),r=t.pow(n,e),o=t.mul(i,r),a=t.mul(t.mul(o,ot),r),c=t.mul(o,t.sub(a,t.ONE));if(!t.eql(t.sqr(c),i))throw new Error("Cannot find square root");return c}}return Dl(s)}const jl=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Bl(s){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=jl.reduce((i,n)=>(i[n]="function",i),e);return Gt(s,t)}function Ml(s,e,t){if(t<ue)throw new Error("invalid exponent, negatives unsupported");if(t===ue)return s.ONE;if(t===se)return e;let i=s.ONE,n=e;for(;t>ue;)t&se&&(i=s.mul(i,n)),n=s.sqr(n),t>>=se;return i}function Hl(s,e){const t=new Array(e.length),i=e.reduce((r,o,a)=>s.is0(o)?r:(t[a]=r,s.mul(r,o)),s.ONE),n=s.inv(i);return e.reduceRight((r,o,a)=>s.is0(o)?r:(t[a]=s.mul(r,t[a]),s.mul(r,o)),n),t}function eo(s,e){const t=e!==void 0?e:s.toString(2).length,i=Math.ceil(t/8);return{nBitLength:t,nByteLength:i}}function to(s,e,t=!1,i={}){if(s<=ue)throw new Error("invalid field: expected ORDER > 0, got "+s);const{nBitLength:n,nByteLength:r}=eo(s,e);if(r>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:s,isLE:t,BITS:n,BYTES:r,MASK:qi(n),ZERO:ue,ONE:se,create:c=>ve(c,s),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return ue<=c&&c<s},is0:c=>c===ue,isOdd:c=>(c&se)===se,neg:c=>ve(-c,s),eql:(c,l)=>c===l,sqr:c=>ve(c*c,s),add:(c,l)=>ve(c+l,s),sub:(c,l)=>ve(c-l,s),mul:(c,l)=>ve(c*l,s),pow:(c,l)=>Ml(a,c,l),div:(c,l)=>ve(c*vi(l,s),s),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>vi(c,s),sqrt:i.sqrt||(c=>(o||(o=Ll(s)),o(a,c))),invertBatch:c=>Hl(a,c),cmov:(c,l,h)=>h?l:c,toBytes:c=>t?Ls(c,r):Vt(c,r),fromBytes:c=>{if(c.length!==r)throw new Error("Field.fromBytes: expected "+r+" bytes, got "+c.length);return t?ls(c):lt(c)}});return Object.freeze(a)}function so(s){if(typeof s!="bigint")throw new Error("field order must be bigint");const e=s.toString(2).length;return Math.ceil(e/8)}function io(s){const e=so(s);return e+Math.ceil(e/2)}function Fl(s,e,t=!1){const i=s.length,n=so(e),r=io(e);if(i<16||i<r||i>1024)throw new Error("expected "+r+"-1024 bytes of input, got "+i);const o=t?ls(s):lt(s),a=ve(o,e-se)+se;return t?Ls(a,n):Vt(a,n)}const Tn=BigInt(0),Es=BigInt(1);function Gs(s,e){const t=e.negate();return s?t:e}function no(s,e){if(!Number.isSafeInteger(s)||s<=0||s>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+s)}function Js(s,e){no(s,e);const t=Math.ceil(e/s)+1,i=2**(s-1);return{windows:t,windowSize:i}}function Vl(s,e){if(!Array.isArray(s))throw new Error("array expected");s.forEach((t,i)=>{if(!(t instanceof e))throw new Error("invalid point at index "+i)})}function zl(s,e){if(!Array.isArray(s))throw new Error("array of scalars expected");s.forEach((t,i)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+i)})}const Ys=new WeakMap,ro=new WeakMap;function Zs(s){return ro.get(s)||1}function Wl(s,e){return{constTimeNegate:Gs,hasPrecomputes(t){return Zs(t)!==1},unsafeLadder(t,i,n=s.ZERO){let r=t;for(;i>Tn;)i&Es&&(n=n.add(r)),r=r.double(),i>>=Es;return n},precomputeWindow(t,i){const{windows:n,windowSize:r}=Js(i,e),o=[];let a=t,c=a;for(let l=0;l<n;l++){c=a,o.push(c);for(let h=1;h<r;h++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,i,n){const{windows:r,windowSize:o}=Js(t,e);let a=s.ZERO,c=s.BASE;const l=BigInt(2**t-1),h=2**t,u=BigInt(t);for(let d=0;d<r;d++){const f=d*o;let y=Number(n&l);n>>=u,y>o&&(y-=h,n+=Es);const w=f,p=f+Math.abs(y)-1,m=d%2!==0,g=y<0;y===0?c=c.add(Gs(m,i[w])):a=a.add(Gs(g,i[p]))}return{p:a,f:c}},wNAFUnsafe(t,i,n,r=s.ZERO){const{windows:o,windowSize:a}=Js(t,e),c=BigInt(2**t-1),l=2**t,h=BigInt(t);for(let u=0;u<o;u++){const d=u*a;if(n===Tn)break;let f=Number(n&c);if(n>>=h,f>a&&(f-=l,n+=Es),f===0)continue;let y=i[d+Math.abs(f)-1];f<0&&(y=y.negate()),r=r.add(y)}return r},getPrecomputes(t,i,n){let r=Ys.get(i);return r||(r=this.precomputeWindow(i,t),t!==1&&Ys.set(i,n(r))),r},wNAFCached(t,i,n){const r=Zs(t);return this.wNAF(r,this.getPrecomputes(r,t,n),i)},wNAFCachedUnsafe(t,i,n,r){const o=Zs(t);return o===1?this.unsafeLadder(t,i,r):this.wNAFUnsafe(o,this.getPrecomputes(o,t,n),i,r)},setWindowSize(t,i){no(i,e),ro.set(t,i),Ys.delete(t)}}}function Kl(s,e,t,i){if(Vl(t,s),zl(i,e),t.length!==i.length)throw new Error("arrays of points and scalars must have equal length");const n=s.ZERO,r=Zr(BigInt(t.length)),o=r>12?r-3:r>4?r-2:r?2:1,a=(1<<o)-1,c=new Array(a+1).fill(n),l=Math.floor((e.BITS-1)/o)*o;let h=n;for(let u=l;u>=0;u-=o){c.fill(n);for(let f=0;f<i.length;f++){const y=i[f],w=Number(y>>BigInt(u)&BigInt(a));c[w]=c[w].add(t[f])}let d=n;for(let f=c.length-1,y=n;f>0;f--)y=y.add(c[f]),d=d.add(y);if(h=h.add(d),u!==0)for(let f=0;f<o;f++)h=h.double()}return h}function oo(s){return Bl(s.Fp),Gt(s,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...eo(s.n,s.nBitLength),...s,p:s.Fp.ORDER})}BigInt(0),BigInt(1),BigInt(2),BigInt(8);const yt=BigInt(0),Qs=BigInt(1);function Gl(s){return Gt(s,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...s})}function Jl(s){const e=Gl(s),{P:t}=e,i=g=>ve(g,t),n=e.montgomeryBits,r=Math.ceil(n/8),o=e.nByteLength,a=e.adjustScalarBytes||(g=>g),c=e.powPminus2||(g=>Xr(g,t-BigInt(2),t));function l(g,I,_){const T=i(g*(I-_));return I=i(I-T),_=i(_+T),[I,_]}const h=(e.a-BigInt(2))/BigInt(4);function u(g,I){ze("u",g,yt,t),ze("scalar",I,yt,t);const _=I,T=g;let P=Qs,O=yt,$=g,b=Qs,L=yt,k;for(let B=BigInt(n-1);B>=yt;B--){const E=_>>B&Qs;L^=E,k=l(L,P,$),P=k[0],$=k[1],k=l(L,O,b),O=k[0],b=k[1],L=E;const N=P+O,A=i(N*N),R=P-O,q=i(R*R),C=A-q,j=$+b,M=$-b,H=i(M*N),Z=i(j*R),G=H+Z,ie=H-Z;$=i(G*G),b=i(T*i(ie*ie)),P=i(A*q),O=i(C*(A+i(h*C)))}k=l(L,P,$),P=k[0],$=k[1],k=l(L,O,b),O=k[0],b=k[1];const x=c(O);return i(P*x)}function d(g){return Ls(i(g),r)}function f(g){const I=be("u coordinate",g,r);return o===32&&(I[31]&=127),ls(I)}function y(g){const I=be("scalar",g),_=I.length;if(_!==r&&_!==o){let T=""+r+" or "+o;throw new Error("invalid scalar, expected "+T+" bytes, got "+_)}return ls(a(I))}function w(g,I){const _=f(I),T=y(g),P=u(_,T);if(P===yt)throw new Error("invalid private or public key received");return d(P)}const p=d(e.Gu);function m(g){return w(g,p)}return{scalarMult:w,scalarMultBase:m,getSharedSecret:(g,I)=>w(g,I),getPublicKey:g=>m(g),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:p}}const Ei=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");BigInt(0);const Yl=BigInt(1),Rn=BigInt(2),Zl=BigInt(3),Ql=BigInt(5);BigInt(8);function Xl(s){const e=BigInt(10),t=BigInt(20),i=BigInt(40),n=BigInt(80),r=Ei,o=s*s%r*s%r,a=_e(o,Rn,r)*o%r,c=_e(a,Yl,r)*s%r,l=_e(c,Ql,r)*c%r,h=_e(l,e,r)*l%r,u=_e(h,t,r)*h%r,d=_e(u,i,r)*u%r,f=_e(d,n,r)*d%r,y=_e(f,n,r)*d%r,w=_e(y,e,r)*l%r;return{pow_p_5_8:_e(w,Rn,r)*s%r,b2:o}}function eh(s){return s[0]&=248,s[31]&=127,s[31]|=64,s}Jl({P:Ei,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:s=>{const e=Ei,{pow_p_5_8:t,b2:i}=Xl(s);return ve(_e(t,Zl,e)*i,e)},adjustScalarBytes:eh,randomBytes:jr});function $n(s){s.lowS!==void 0&&Mt("lowS",s.lowS),s.prehash!==void 0&&Mt("prehash",s.prehash)}function th(s){const e=oo(s);Gt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:i,a:n}=e;if(t){if(!i.eql(n,i.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:sh,hexToBytes:ih}=xl;class nh extends Error{constructor(e=""){super(e)}}const Fe={Err:nh,_tlv:{encode:(s,e)=>{const{Err:t}=Fe;if(s<0||s>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const i=e.length/2,n=xt(i);if(n.length/2&128)throw new t("tlv.encode: long form length too big");const r=i>127?xt(n.length/2|128):"";return xt(s)+r+n+e},decode(s,e){const{Err:t}=Fe;let i=0;if(s<0||s>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[i++]!==s)throw new t("tlv.decode: wrong tlv");const n=e[i++],r=!!(n&128);let o=0;if(!r)o=n;else{const c=n&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(i,i+c);if(l.length!==c)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const h of l)o=o<<8|h;if(i+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(i,i+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(i+o)}}},_int:{encode(s){const{Err:e}=Fe;if(s<Ve)throw new e("integer: negative integers are not allowed");let t=xt(s);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(s){const{Err:e}=Fe;if(s[0]&128)throw new e("invalid signature integer: negative");if(s[0]===0&&!(s[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return sh(s)}},toSig(s){const{Err:e,_int:t,_tlv:i}=Fe,n=typeof s=="string"?ih(s):s;ds(n);const{v:r,l:o}=i.decode(48,n);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=i.decode(2,r),{v:l,l:h}=i.decode(2,c);if(h.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(s){const{_tlv:e,_int:t}=Fe,i=e.encode(2,t.encode(s.r)),n=e.encode(2,t.encode(s.s)),r=i+n;return e.encode(48,r)}},Ve=BigInt(0),le=BigInt(1);BigInt(2);const kn=BigInt(3);BigInt(4);function rh(s){const e=th(s),{Fp:t}=e,i=to(e.n,e.nBitLength),n=e.toBytes||((w,p,m)=>{const g=p.toAffine();return hs(Uint8Array.from([4]),t.toBytes(g.x),t.toBytes(g.y))}),r=e.fromBytes||(w=>{const p=w.subarray(1),m=t.fromBytes(p.subarray(0,t.BYTES)),g=t.fromBytes(p.subarray(t.BYTES,2*t.BYTES));return{x:m,y:g}});function o(w){const{a:p,b:m}=e,g=t.sqr(w),I=t.mul(g,w);return t.add(t.add(I,t.mul(w,p)),m)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function a(w){return js(w,le,e.n)}function c(w){const{allowedPrivateKeyLengths:p,nByteLength:m,wrapPrivateKey:g,n:I}=e;if(p&&typeof w!="bigint"){if(dt(w)&&(w=Ht(w)),typeof w!="string"||!p.includes(w.length))throw new Error("invalid private key");w=w.padStart(m*2,"0")}let _;try{_=typeof w=="bigint"?w:lt(be("private key",w,m))}catch{throw new Error("invalid private key, expected hex or "+m+" bytes, got "+typeof w)}return g&&(_=ve(_,I)),ze("private key",_,le,I),_}function l(w){if(!(w instanceof d))throw new Error("ProjectivePoint expected")}const h=mi((w,p)=>{const{px:m,py:g,pz:I}=w;if(t.eql(I,t.ONE))return{x:m,y:g};const _=w.is0();p==null&&(p=_?t.ONE:t.inv(I));const T=t.mul(m,p),P=t.mul(g,p),O=t.mul(I,p);if(_)return{x:t.ZERO,y:t.ZERO};if(!t.eql(O,t.ONE))throw new Error("invZ was invalid");return{x:T,y:P}}),u=mi(w=>{if(w.is0()){if(e.allowInfinityPoint&&!t.is0(w.py))return;throw new Error("bad point: ZERO")}const{x:p,y:m}=w.toAffine();if(!t.isValid(p)||!t.isValid(m))throw new Error("bad point: x or y not FE");const g=t.sqr(m),I=o(p);if(!t.eql(g,I))throw new Error("bad point: equation left != right");if(!w.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class d{constructor(p,m,g){if(this.px=p,this.py=m,this.pz=g,p==null||!t.isValid(p))throw new Error("x required");if(m==null||!t.isValid(m))throw new Error("y required");if(g==null||!t.isValid(g))throw new Error("z required");Object.freeze(this)}static fromAffine(p){const{x:m,y:g}=p||{};if(!p||!t.isValid(m)||!t.isValid(g))throw new Error("invalid affine point");if(p instanceof d)throw new Error("projective point not allowed");const I=_=>t.eql(_,t.ZERO);return I(m)&&I(g)?d.ZERO:new d(m,g,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(p){const m=t.invertBatch(p.map(g=>g.pz));return p.map((g,I)=>g.toAffine(m[I])).map(d.fromAffine)}static fromHex(p){const m=d.fromAffine(r(be("pointHex",p)));return m.assertValidity(),m}static fromPrivateKey(p){return d.BASE.multiply(c(p))}static msm(p,m){return Kl(d,i,p,m)}_setWindowSize(p){y.setWindowSize(this,p)}assertValidity(){u(this)}hasEvenY(){const{y:p}=this.toAffine();if(t.isOdd)return!t.isOdd(p);throw new Error("Field doesn't support isOdd")}equals(p){l(p);const{px:m,py:g,pz:I}=this,{px:_,py:T,pz:P}=p,O=t.eql(t.mul(m,P),t.mul(_,I)),$=t.eql(t.mul(g,P),t.mul(T,I));return O&&$}negate(){return new d(this.px,t.neg(this.py),this.pz)}double(){const{a:p,b:m}=e,g=t.mul(m,kn),{px:I,py:_,pz:T}=this;let P=t.ZERO,O=t.ZERO,$=t.ZERO,b=t.mul(I,I),L=t.mul(_,_),k=t.mul(T,T),x=t.mul(I,_);return x=t.add(x,x),$=t.mul(I,T),$=t.add($,$),P=t.mul(p,$),O=t.mul(g,k),O=t.add(P,O),P=t.sub(L,O),O=t.add(L,O),O=t.mul(P,O),P=t.mul(x,P),$=t.mul(g,$),k=t.mul(p,k),x=t.sub(b,k),x=t.mul(p,x),x=t.add(x,$),$=t.add(b,b),b=t.add($,b),b=t.add(b,k),b=t.mul(b,x),O=t.add(O,b),k=t.mul(_,T),k=t.add(k,k),b=t.mul(k,x),P=t.sub(P,b),$=t.mul(k,L),$=t.add($,$),$=t.add($,$),new d(P,O,$)}add(p){l(p);const{px:m,py:g,pz:I}=this,{px:_,py:T,pz:P}=p;let O=t.ZERO,$=t.ZERO,b=t.ZERO;const L=e.a,k=t.mul(e.b,kn);let x=t.mul(m,_),B=t.mul(g,T),E=t.mul(I,P),N=t.add(m,g),A=t.add(_,T);N=t.mul(N,A),A=t.add(x,B),N=t.sub(N,A),A=t.add(m,I);let R=t.add(_,P);return A=t.mul(A,R),R=t.add(x,E),A=t.sub(A,R),R=t.add(g,I),O=t.add(T,P),R=t.mul(R,O),O=t.add(B,E),R=t.sub(R,O),b=t.mul(L,A),O=t.mul(k,E),b=t.add(O,b),O=t.sub(B,b),b=t.add(B,b),$=t.mul(O,b),B=t.add(x,x),B=t.add(B,x),E=t.mul(L,E),A=t.mul(k,A),B=t.add(B,E),E=t.sub(x,E),E=t.mul(L,E),A=t.add(A,E),x=t.mul(B,A),$=t.add($,x),x=t.mul(R,A),O=t.mul(N,O),O=t.sub(O,x),x=t.mul(N,B),b=t.mul(R,b),b=t.add(b,x),new d(O,$,b)}subtract(p){return this.add(p.negate())}is0(){return this.equals(d.ZERO)}wNAF(p){return y.wNAFCached(this,p,d.normalizeZ)}multiplyUnsafe(p){const{endo:m,n:g}=e;ze("scalar",p,Ve,g);const I=d.ZERO;if(p===Ve)return I;if(this.is0()||p===le)return this;if(!m||y.hasPrecomputes(this))return y.wNAFCachedUnsafe(this,p,d.normalizeZ);let{k1neg:_,k1:T,k2neg:P,k2:O}=m.splitScalar(p),$=I,b=I,L=this;for(;T>Ve||O>Ve;)T&le&&($=$.add(L)),O&le&&(b=b.add(L)),L=L.double(),T>>=le,O>>=le;return _&&($=$.negate()),P&&(b=b.negate()),b=new d(t.mul(b.px,m.beta),b.py,b.pz),$.add(b)}multiply(p){const{endo:m,n:g}=e;ze("scalar",p,le,g);let I,_;if(m){const{k1neg:T,k1:P,k2neg:O,k2:$}=m.splitScalar(p);let{p:b,f:L}=this.wNAF(P),{p:k,f:x}=this.wNAF($);b=y.constTimeNegate(T,b),k=y.constTimeNegate(O,k),k=new d(t.mul(k.px,m.beta),k.py,k.pz),I=b.add(k),_=L.add(x)}else{const{p:T,f:P}=this.wNAF(p);I=T,_=P}return d.normalizeZ([I,_])[0]}multiplyAndAddUnsafe(p,m,g){const I=d.BASE,_=(P,O)=>O===Ve||O===le||!P.equals(I)?P.multiplyUnsafe(O):P.multiply(O),T=_(this,m).add(_(p,g));return T.is0()?void 0:T}toAffine(p){return h(this,p)}isTorsionFree(){const{h:p,isTorsionFree:m}=e;if(p===le)return!0;if(m)return m(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:p,clearCofactor:m}=e;return p===le?this:m?m(d,this):this.multiplyUnsafe(e.h)}toRawBytes(p=!0){return Mt("isCompressed",p),this.assertValidity(),n(d,this,p)}toHex(p=!0){return Mt("isCompressed",p),Ht(this.toRawBytes(p))}}d.BASE=new d(e.Gx,e.Gy,t.ONE),d.ZERO=new d(t.ZERO,t.ONE,t.ZERO);const f=e.nBitLength,y=Wl(d,e.endo?Math.ceil(f/2):f);return{CURVE:e,ProjectivePoint:d,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:a}}function oh(s){const e=oo(s);return Gt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function ah(s){const e=oh(s),{Fp:t,n:i}=e,n=t.BYTES+1,r=2*t.BYTES+1;function o(E){return ve(E,i)}function a(E){return vi(E,i)}const{ProjectivePoint:c,normPrivateKeyToScalar:l,weierstrassEquation:h,isWithinCurveOrder:u}=rh({...e,toBytes(E,N,A){const R=N.toAffine(),q=t.toBytes(R.x),C=hs;return Mt("isCompressed",A),A?C(Uint8Array.from([N.hasEvenY()?2:3]),q):C(Uint8Array.from([4]),q,t.toBytes(R.y))},fromBytes(E){const N=E.length,A=E[0],R=E.subarray(1);if(N===n&&(A===2||A===3)){const q=lt(R);if(!js(q,le,t.ORDER))throw new Error("Point is not on curve");const C=h(q);let j;try{j=t.sqrt(C)}catch(H){const Z=H instanceof Error?": "+H.message:"";throw new Error("Point is not on curve"+Z)}const M=(j&le)===le;return(A&1)===1!==M&&(j=t.neg(j)),{x:q,y:j}}else if(N===r&&A===4){const q=t.fromBytes(R.subarray(0,t.BYTES)),C=t.fromBytes(R.subarray(t.BYTES,2*t.BYTES));return{x:q,y:C}}else{const q=n,C=r;throw new Error("invalid Point, expected length of "+q+", or uncompressed "+C+", got "+N)}}}),d=E=>Ht(Vt(E,e.nByteLength));function f(E){const N=i>>le;return E>N}function y(E){return f(E)?o(-E):E}const w=(E,N,A)=>lt(E.slice(N,A));class p{constructor(N,A,R){this.r=N,this.s=A,this.recovery=R,this.assertValidity()}static fromCompact(N){const A=e.nByteLength;return N=be("compactSignature",N,A*2),new p(w(N,0,A),w(N,A,2*A))}static fromDER(N){const{r:A,s:R}=Fe.toSig(be("DER",N));return new p(A,R)}assertValidity(){ze("r",this.r,le,i),ze("s",this.s,le,i)}addRecoveryBit(N){return new p(this.r,this.s,N)}recoverPublicKey(N){const{r:A,s:R,recovery:q}=this,C=P(be("msgHash",N));if(q==null||![0,1,2,3].includes(q))throw new Error("recovery id invalid");const j=q===2||q===3?A+e.n:A;if(j>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const M=q&1?"03":"02",H=c.fromHex(M+d(j)),Z=a(j),G=o(-C*Z),ie=o(R*Z),ae=c.BASE.multiplyAndAddUnsafe(H,G,ie);if(!ae)throw new Error("point at infinify");return ae.assertValidity(),ae}hasHighS(){return f(this.s)}normalizeS(){return this.hasHighS()?new p(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return Ft(this.toDERHex())}toDERHex(){return Fe.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Ft(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const m={isValidPrivateKey(E){try{return l(E),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const E=io(e.n);return Fl(e.randomBytes(E),e.n)},precompute(E=8,N=c.BASE){return N._setWindowSize(E),N.multiply(BigInt(3)),N}};function g(E,N=!0){return c.fromPrivateKey(E).toRawBytes(N)}function I(E){const N=dt(E),A=typeof E=="string",R=(N||A)&&E.length;return N?R===n||R===r:A?R===2*n||R===2*r:E instanceof c}function _(E,N,A=!0){if(I(E))throw new Error("first arg must be private key");if(!I(N))throw new Error("second arg must be public key");return c.fromHex(N).multiply(l(E)).toRawBytes(A)}const T=e.bits2int||function(E){if(E.length>8192)throw new Error("input is too large");const N=lt(E),A=E.length*8-e.nBitLength;return A>0?N>>BigInt(A):N},P=e.bits2int_modN||function(E){return o(T(E))},O=qi(e.nBitLength);function $(E){return ze("num < 2^"+e.nBitLength,E,Ve,O),Vt(E,e.nByteLength)}function b(E,N,A=L){if(["recovered","canonical"].some(ne=>ne in A))throw new Error("sign() legacy options not supported");const{hash:R,randomBytes:q}=e;let{lowS:C,prehash:j,extraEntropy:M}=A;C==null&&(C=!0),E=be("msgHash",E),$n(A),j&&(E=be("prehashed msgHash",R(E)));const H=P(E),Z=l(N),G=[$(Z),$(H)];if(M!=null&&M!==!1){const ne=M===!0?q(t.BYTES):M;G.push(be("extraEntropy",ne))}const ie=hs(...G),ae=H;function pe(ne){const re=T(ne);if(!u(re))return;const st=a(re),De=c.BASE.multiply(re).toAffine(),$e=o(De.x);if($e===Ve)return;const Le=o(st*o(ae+$e*Z));if(Le===Ve)return;let je=(De.x===$e?0:2)|Number(De.y&le),fs=Le;return C&&f(Le)&&(fs=y(Le),je^=1),new p($e,fs,je)}return{seed:ie,k2sig:pe}}const L={lowS:e.lowS,prehash:!1},k={lowS:e.lowS,prehash:!1};function x(E,N,A=L){const{seed:R,k2sig:q}=b(E,N,A),C=e;return Qr(C.hash.outputLen,C.nByteLength,C.hmac)(R,q)}c.BASE._setWindowSize(8);function B(E,N,A,R=k){var Le;const q=E;N=be("msgHash",N),A=be("publicKey",A);const{lowS:C,prehash:j,format:M}=R;if($n(R),"strict"in R)throw new Error("options.strict was renamed to lowS");if(M!==void 0&&M!=="compact"&&M!=="der")throw new Error("format must be compact or der");const H=typeof q=="string"||dt(q),Z=!H&&!M&&typeof q=="object"&&q!==null&&typeof q.r=="bigint"&&typeof q.s=="bigint";if(!H&&!Z)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let G,ie;try{if(Z&&(G=new p(q.r,q.s)),H){try{M!=="compact"&&(G=p.fromDER(q))}catch(je){if(!(je instanceof Fe.Err))throw je}!G&&M!=="der"&&(G=p.fromCompact(q))}ie=c.fromHex(A)}catch{return!1}if(!G||C&&G.hasHighS())return!1;j&&(N=e.hash(N));const{r:ae,s:pe}=G,ne=P(N),re=a(pe),st=o(ne*re),De=o(ae*re),$e=(Le=c.BASE.multiplyAndAddUnsafe(ie,st,De))==null?void 0:Le.toAffine();return $e?o($e.x)===ae:!1}return{CURVE:e,getPublicKey:g,getSharedSecret:_,sign:x,verify:B,ProjectivePoint:c,Signature:p,utils:m}}function ch(s){return{hash:s,hmac:(e,...t)=>Yr(s,e,wc(...t)),randomBytes:jr}}function lh(s,e){const t=i=>ah({...s,...ch(i)});return{...t(e),create:t}}const ao=to(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),hh=ao.create(BigInt("-3")),uh=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");lh({a:hh,b:uh,Fp:ao,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},$i);const bi="base16",bs="base64pad",is="base64url",dh="utf8",Xs=1,ph=2;function ei(s){const e=$i(Rr(s,bi));return $r(e,bi)}function vt(s){const e=$i(Rr(s,dh));return $r(e,bi)}function Is(s,e,t){return`${s}?wc_ev=${t}&topic=${e}`}var fh=Object.defineProperty,gh=Object.defineProperties,wh=Object.getOwnPropertyDescriptors,qn=Object.getOwnPropertySymbols,mh=Object.prototype.hasOwnProperty,yh=Object.prototype.propertyIsEnumerable,xn=(s,e,t)=>e in s?fh(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,vh=(s,e)=>{for(var t in e||(e={}))mh.call(e,t)&&xn(s,t,e[t]);if(qn)for(var t of qn(e))yh.call(e,t)&&xn(s,t,e[t]);return s},Eh=(s,e)=>gh(s,wh(e));function Jt(s){const e=[];return s.forEach(t=>{const[i,n]=t.split(":");e.push(`${i}:${n}`)}),e}function bh(s){const e=[];return Object.values(s).forEach(t=>{e.push(...Jt(t.accounts))}),e}function Ih(s,e){const t=[];return Object.values(s).forEach(i=>{Jt(i.accounts).includes(e)&&t.push(...i.methods)}),t}function Ch(s,e){const t=[];return Object.values(s).forEach(i=>{Jt(i.accounts).includes(e)&&t.push(...i.events)}),t}function Bs(s){return s.includes(":")}function Ut(s){return Bs(s)?s.split(":")[0]:s}function Un(s){var e,t,i;const n={};if(!tt(s))return n;for(const[r,o]of Object.entries(s)){const a=Bs(r)?[r]:o.chains,c=o.methods||[],l=o.events||[],h=Ut(r);n[h]=Eh(vh({},n[h]),{chains:Ue(a,(e=n[h])==null?void 0:e.chains),methods:Ue(c,(t=n[h])==null?void 0:t.methods),events:Ue(l,(i=n[h])==null?void 0:i.events)})}return n}function Ah(s){const e={};return s==null||s.forEach(t=>{var i;const[n,r]=t.split(":");e[n]||(e[n]={accounts:[],chains:[],events:[],methods:[]}),e[n].accounts.push(t),(i=e[n].chains)==null||i.push(`${n}:${r}`)}),e}function Dn(s,e){e=e.map(i=>i.replace("did:pkh:",""));const t=Ah(e);for(const[i,n]of Object.entries(t))n.methods?n.methods=Ue(n.methods,s):n.methods=s,n.events=["chainChanged","accountsChanged"];return t}function Nh(s,e){var t,i,n,r,o,a;const c=Un(s),l=Un(e),h={},u=Object.keys(c).concat(Object.keys(l));for(const d of u)h[d]={chains:Ue((t=c[d])==null?void 0:t.chains,(i=l[d])==null?void 0:i.chains),methods:Ue((n=c[d])==null?void 0:n.methods,(r=l[d])==null?void 0:r.methods),events:Ue((o=c[d])==null?void 0:o.events,(a=l[d])==null?void 0:a.events)};return h}const Ph={INVALID_METHOD:{message:"Invalid method.",code:1001},INVALID_EVENT:{message:"Invalid event.",code:1002},INVALID_UPDATE_REQUEST:{message:"Invalid update request.",code:1003},INVALID_EXTEND_REQUEST:{message:"Invalid extend request.",code:1004},INVALID_SESSION_SETTLE_REQUEST:{message:"Invalid session settle request.",code:1005},UNAUTHORIZED_METHOD:{message:"Unauthorized method.",code:3001},UNAUTHORIZED_EVENT:{message:"Unauthorized event.",code:3002},UNAUTHORIZED_UPDATE_REQUEST:{message:"Unauthorized update request.",code:3003},UNAUTHORIZED_EXTEND_REQUEST:{message:"Unauthorized extend request.",code:3004},USER_REJECTED:{message:"User rejected.",code:5e3},USER_REJECTED_CHAINS:{message:"User rejected chains.",code:5001},USER_REJECTED_METHODS:{message:"User rejected methods.",code:5002},USER_REJECTED_EVENTS:{message:"User rejected events.",code:5003},UNSUPPORTED_CHAINS:{message:"Unsupported chains.",code:5100},UNSUPPORTED_METHODS:{message:"Unsupported methods.",code:5101},UNSUPPORTED_EVENTS:{message:"Unsupported events.",code:5102},UNSUPPORTED_ACCOUNTS:{message:"Unsupported accounts.",code:5103},UNSUPPORTED_NAMESPACE_KEY:{message:"Unsupported namespace key.",code:5104},USER_DISCONNECTED:{message:"User disconnected.",code:6e3},SESSION_SETTLEMENT_FAILED:{message:"Session settlement failed.",code:7e3},WC_METHOD_UNSUPPORTED:{message:"Unsupported wc_ method.",code:10001}},Sh={NOT_INITIALIZED:{message:"Not initialized.",code:1},NO_MATCHING_KEY:{message:"No matching key.",code:2},RESTORE_WILL_OVERRIDE:{message:"Restore will override.",code:3},RESUBSCRIBED:{message:"Resubscribed.",code:4},MISSING_OR_INVALID:{message:"Missing or invalid.",code:5},EXPIRED:{message:"Expired.",code:6},UNKNOWN_TYPE:{message:"Unknown type.",code:7},MISMATCHED_TOPIC:{message:"Mismatched topic.",code:8},NON_CONFORMING_NAMESPACES:{message:"Non conforming namespaces.",code:9}};function D(s,e){const{message:t,code:i}=Sh[s];return{message:e?`${t} ${e}`:t,code:i}}function X(s,e){const{message:t,code:i}=Ph[s];return{message:e?`${t} ${e}`:t,code:i}}function et(s,e){return!!Array.isArray(s)}function tt(s){return Object.getPrototypeOf(s)===Object.prototype&&Object.keys(s).length}function Ee(s){return typeof s>"u"}function he(s,e){return e&&Ee(s)?!0:typeof s=="string"&&!!s.trim().length}function xi(s,e){return e&&Ee(s)?!0:typeof s=="number"&&!isNaN(s)}function Oh(s,e){const{requiredNamespaces:t}=e,i=Object.keys(s.namespaces),n=Object.keys(t);let r=!0;return ct(n,i)?(i.forEach(o=>{const{accounts:a,methods:c,events:l}=s.namespaces[o],h=Jt(a),u=t[o];(!ct(kr(o,u),h)||!ct(u.methods,c)||!ct(u.events,l))&&(r=!1)}),r):!1}function qs(s){return he(s,!1)&&s.includes(":")?s.split(":").length===2:!1}function _h(s){if(he(s,!1)&&s.includes(":")){const e=s.split(":");if(e.length===3){const t=e[0]+":"+e[1];return!!e[2]&&qs(t)}}return!1}function Th(s,e){let t=null;return he(s==null?void 0:s.publicKey,!1)||(t=D("MISSING_OR_INVALID",`${e} controller public key should be a string`)),t}function Ln(s){let e=!0;return et(s)?s.length&&(e=s.every(t=>he(t,!1))):e=!1,e}function Rh(s,e,t){let i=null;return et(e)&&e.length?e.forEach(n=>{i||qs(n)||(i=X("UNSUPPORTED_CHAINS",`${t}, chain ${n} should be a string and conform to "namespace:chainId" format`))}):qs(s)||(i=X("UNSUPPORTED_CHAINS",`${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),i}function $h(s,e,t){let i=null;return Object.entries(s).forEach(([n,r])=>{if(i)return;const o=Rh(n,kr(n,r),`${e} ${t}`);o&&(i=o)}),i}function kh(s,e){let t=null;return et(s)?s.forEach(i=>{t||_h(i)||(t=X("UNSUPPORTED_ACCOUNTS",`${e}, account ${i} should be a string and conform to "namespace:chainId:address" format`))}):t=X("UNSUPPORTED_ACCOUNTS",`${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),t}function qh(s,e){let t=null;return Object.values(s).forEach(i=>{if(t)return;const n=kh(i==null?void 0:i.accounts,`${e} namespace`);n&&(t=n)}),t}function xh(s,e){let t=null;return Ln(s==null?void 0:s.methods)?Ln(s==null?void 0:s.events)||(t=X("UNSUPPORTED_EVENTS",`${e}, events should be an array of strings or empty array for no events`)):t=X("UNSUPPORTED_METHODS",`${e}, methods should be an array of strings or empty array for no methods`),t}function co(s,e){let t=null;return Object.values(s).forEach(i=>{if(t)return;const n=xh(i,`${e}, namespace`);n&&(t=n)}),t}function Uh(s,e,t){let i=null;if(s&&tt(s)){const n=co(s,e);n&&(i=n);const r=$h(s,e,t);r&&(i=r)}else i=D("MISSING_OR_INVALID",`${e}, ${t} should be an object with data`);return i}function ti(s,e){let t=null;if(s&&tt(s)){const i=co(s,e);i&&(t=i);const n=qh(s,e);n&&(t=n)}else t=D("MISSING_OR_INVALID",`${e}, namespaces should be an object with data`);return t}function lo(s){return he(s.protocol,!0)}function Dh(s,e){let t=!1;return s?s&&et(s)&&s.length&&s.forEach(i=>{t=lo(i)}):t=!0,t}function Lh(s){return typeof s=="number"}function Se(s){return typeof s<"u"&&typeof s!==null}function jh(s){return!(!s||typeof s!="object"||!s.code||!xi(s.code,!1)||!s.message||!he(s.message,!1))}function Bh(s){return!(Ee(s)||!he(s.method,!1))}function Mh(s){return!(Ee(s)||Ee(s.result)&&Ee(s.error)||!xi(s.id,!1)||!he(s.jsonrpc,!1))}function Hh(s){return!(Ee(s)||!he(s.name,!1))}function jn(s,e){return!(!qs(e)||!bh(s).includes(e))}function Fh(s,e,t){return he(t,!1)?Ih(s,e).includes(t):!1}function Vh(s,e,t){return he(t,!1)?Ch(s,e).includes(t):!1}function Bn(s,e,t){let i=null;const n=zh(s),r=Wh(e),o=Object.keys(n),a=Object.keys(r),c=Mn(Object.keys(s)),l=Mn(Object.keys(e)),h=c.filter(u=>!l.includes(u));return h.length&&(i=D("NON_CONFORMING_NAMESPACES",`${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${h.toString()}
      Received: ${Object.keys(e).toString()}`)),ct(o,a)||(i=D("NON_CONFORMING_NAMESPACES",`${t} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)),Object.keys(e).forEach(u=>{if(!u.includes(":")||i)return;const d=Jt(e[u].accounts);d.includes(u)||(i=D("NON_CONFORMING_NAMESPACES",`${t} namespaces accounts don't satisfy namespace accounts for ${u}
        Required: ${u}
        Approved: ${d.toString()}`))}),o.forEach(u=>{i||(ct(n[u].methods,r[u].methods)?ct(n[u].events,r[u].events)||(i=D("NON_CONFORMING_NAMESPACES",`${t} namespaces events don't satisfy namespace events for ${u}`)):i=D("NON_CONFORMING_NAMESPACES",`${t} namespaces methods don't satisfy namespace methods for ${u}`))}),i}function zh(s){const e={};return Object.keys(s).forEach(t=>{var i;t.includes(":")?e[t]=s[t]:(i=s[t].chains)==null||i.forEach(n=>{e[n]={methods:s[t].methods,events:s[t].events}})}),e}function Mn(s){return[...new Set(s.map(e=>e.includes(":")?e.split(":")[0]:e))]}function Wh(s){const e={};return Object.keys(s).forEach(t=>{if(t.includes(":"))e[t]=s[t];else{const i=Jt(s[t].accounts);i==null||i.forEach(n=>{e[n]={accounts:s[t].accounts.filter(r=>r.includes(`${n}:`)),methods:s[t].methods,events:s[t].events}})}}),e}function Kh(s,e){return xi(s,!1)&&s<=e.max&&s>=e.min}const si={};class ns{static get(e){return si[e]}static set(e,t){si[e]=t}static delete(e){delete si[e]}}const ho="wc",uo=2,po="client",Ui=`${ho}@${uo}:${po}:`,ii={name:po,logger:"error"},Hn="WALLETCONNECT_DEEPLINK_CHOICE",Gh="proposal",Fn="Proposal expired",Jh="session",Et=F.SEVEN_DAYS,Yh="engine",ce={wc_sessionPropose:{req:{ttl:F.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:F.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:F.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:F.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:F.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:F.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:F.ONE_DAY,prompt:!1,tag:1104},res:{ttl:F.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:F.ONE_DAY,prompt:!1,tag:1106},res:{ttl:F.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:F.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:F.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:F.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:F.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:F.ONE_DAY,prompt:!1,tag:1112},res:{ttl:F.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:F.ONE_DAY,prompt:!1,tag:1114},res:{ttl:F.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:F.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:F.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:F.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:F.FIVE_MINUTES,prompt:!1,tag:1119}}},ni={min:F.FIVE_MINUTES,max:F.SEVEN_DAYS},qe={idle:"IDLE",active:"ACTIVE"},Vn={eth_sendTransaction:{key:""},eth_sendRawTransaction:{key:""},wallet_sendCalls:{key:""},solana_signTransaction:{key:"signature"},solana_signAllTransactions:{key:"transactions"},solana_signAndSendTransaction:{key:"signature"}},Zh="request",Qh=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],Xh="wc",eu="auth",tu="authKeys",su="pairingTopics",iu="requests",Ms=`${Xh}@${1.5}:${eu}:`,Ts=`${Ms}:PUB_KEY`;var nu=Object.defineProperty,ru=Object.defineProperties,ou=Object.getOwnPropertyDescriptors,zn=Object.getOwnPropertySymbols,au=Object.prototype.hasOwnProperty,cu=Object.prototype.propertyIsEnumerable,Ii=(s,e,t)=>e in s?nu(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,Y=(s,e)=>{for(var t in e||(e={}))au.call(e,t)&&Ii(s,t,e[t]);if(zn)for(var t of zn(e))cu.call(e,t)&&Ii(s,t,e[t]);return s},fe=(s,e)=>ru(s,ou(e)),v=(s,e,t)=>Ii(s,typeof e!="symbol"?e+"":e,t);class lu extends qo{constructor(e){super(e),v(this,"name",Yh),v(this,"events",new dr),v(this,"initialized",!1),v(this,"requestQueue",{state:qe.idle,queue:[]}),v(this,"sessionRequestQueue",{state:qe.idle,queue:[]}),v(this,"requestQueueDelay",F.ONE_SECOND),v(this,"expectedPairingMethodMap",new Map),v(this,"recentlyDeletedMap",new Map),v(this,"recentlyDeletedLimit",200),v(this,"relayMessageCache",[]),v(this,"pendingSessions",new Map),v(this,"init",async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(ce)}),this.initialized=!0,setTimeout(async()=>{await this.processPendingMessageEvents(),this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},F.toMiliseconds(this.requestQueueDelay)))}),v(this,"connect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();const i=fe(Y({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(i),i.optionalNamespaces=Nh(i.requiredNamespaces,i.optionalNamespaces),i.requiredNamespaces={};const{pairingTopic:n,requiredNamespaces:r,optionalNamespaces:o,sessionProperties:a,scopedProperties:c,relays:l}=i;let h=n,u,d=!1;try{if(h){const P=this.client.core.pairing.pairings.get(h);this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),d=P.active}}catch(P){throw this.client.logger.error(`connect() -> pairing.get(${h}) failed`),P}if(!h||!d){const{topic:P,uri:O}=await this.client.core.pairing.create();h=P,u=O}if(!h){const{message:P}=D("NO_MATCHING_KEY",`connect() pairing topic: ${h}`);throw new Error(P)}const f=await this.client.core.crypto.generateKeyPair(),y=ce.wc_sessionPropose.req.ttl||F.FIVE_MINUTES,w=we(y),p=fe(Y(Y({requiredNamespaces:r,optionalNamespaces:o,relays:l??[{protocol:Uo}],proposer:{publicKey:f,metadata:this.client.metadata},expiryTimestamp:w,pairingTopic:h},a&&{sessionProperties:a}),c&&{scopedProperties:c}),{id:Ke()}),m=J("session_connect",p.id),{reject:g,resolve:I,done:_}=gt(y,Fn),T=({id:P})=>{P===p.id&&(this.client.events.off("proposal_expire",T),this.pendingSessions.delete(p.id),this.events.emit(m,{error:{message:Fn,code:0}}))};return this.client.events.on("proposal_expire",T),this.events.once(m,({error:P,session:O})=>{this.client.events.off("proposal_expire",T),P?g(P):O&&I(O)}),await this.sendRequest({topic:h,method:"wc_sessionPropose",params:p,throwOnFailedPublish:!0,clientRpcId:p.id}),await this.setProposal(p.id,p),{uri:u,approval:_}}),v(this,"pair",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(t)}catch(i){throw this.client.logger.error("pair() failed"),i}}),v(this,"approve",async t=>{var i,n,r;const o=this.client.core.eventClient.createEvent({properties:{topic:(i=t==null?void 0:t.id)==null?void 0:i.toString(),trace:[Pe.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(b){throw o.setError(it.no_internet_connection),b}try{await this.isValidProposalId(t==null?void 0:t.id)}catch(b){throw this.client.logger.error(`approve() -> proposal.get(${t==null?void 0:t.id}) failed`),o.setError(it.proposal_not_found),b}try{await this.isValidApprove(t)}catch(b){throw this.client.logger.error("approve() -> isValidApprove() failed"),o.setError(it.session_approve_namespace_validation_failure),b}const{id:a,relayProtocol:c,namespaces:l,sessionProperties:h,scopedProperties:u,sessionConfig:d}=t,f=this.client.proposal.get(a);this.client.core.eventClient.deleteEvent({eventId:o.eventId});const{pairingTopic:y,proposer:w,requiredNamespaces:p,optionalNamespaces:m}=f;let g=(n=this.client.core.eventClient)==null?void 0:n.getEvent({topic:y});g||(g=(r=this.client.core.eventClient)==null?void 0:r.createEvent({type:Pe.session_approve_started,properties:{topic:y,trace:[Pe.session_approve_started,Pe.session_namespaces_validation_success]}}));const I=await this.client.core.crypto.generateKeyPair(),_=w.publicKey,T=await this.client.core.crypto.generateSharedKey(I,_),P=Y(Y(Y({relay:{protocol:c??"irn"},namespaces:l,controller:{publicKey:I,metadata:this.client.metadata},expiry:we(Et)},h&&{sessionProperties:h}),u&&{scopedProperties:u}),d&&{sessionConfig:d}),O=oe.relay;g.addTrace(Pe.subscribing_session_topic);try{await this.client.core.relayer.subscribe(T,{transportType:O})}catch(b){throw g.setError(it.subscribe_session_topic_failure),b}g.addTrace(Pe.subscribe_session_topic_success);const $=fe(Y({},P),{topic:T,requiredNamespaces:p,optionalNamespaces:m,pairingTopic:y,acknowledged:!1,self:P.controller,peer:{publicKey:w.publicKey,metadata:w.metadata},controller:I,transportType:oe.relay});await this.client.session.set(T,$),g.addTrace(Pe.store_session);try{g.addTrace(Pe.publishing_session_settle),await this.sendRequest({topic:T,method:"wc_sessionSettle",params:P,throwOnFailedPublish:!0}).catch(b=>{throw g==null||g.setError(it.session_settle_publish_failure),b}),g.addTrace(Pe.session_settle_publish_success),g.addTrace(Pe.publishing_session_approve),await this.sendResult({id:a,topic:y,result:{relay:{protocol:c??"irn"},responderPublicKey:I},throwOnFailedPublish:!0}).catch(b=>{throw g==null||g.setError(it.session_approve_publish_failure),b}),g.addTrace(Pe.session_approve_publish_success)}catch(b){throw this.client.logger.error(b),this.client.session.delete(T,X("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(T),b}return this.client.core.eventClient.deleteEvent({eventId:g.eventId}),await this.client.core.pairing.updateMetadata({topic:y,metadata:w.metadata}),await this.client.proposal.delete(a,X("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:y}),await this.setExpiry(T,we(Et)),{topic:T,acknowledged:()=>Promise.resolve(this.client.session.get(T))}}),v(this,"reject",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(t)}catch(o){throw this.client.logger.error("reject() -> isValidReject() failed"),o}const{id:i,reason:n}=t;let r;try{r=this.client.proposal.get(i).pairingTopic}catch(o){throw this.client.logger.error(`reject() -> proposal.get(${i}) failed`),o}r&&(await this.sendError({id:i,topic:r,error:n,rpcOpts:ce.wc_sessionPropose.reject}),await this.client.proposal.delete(i,X("USER_DISCONNECTED")))}),v(this,"update",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(t)}catch(u){throw this.client.logger.error("update() -> isValidUpdate() failed"),u}const{topic:i,namespaces:n}=t,{done:r,resolve:o,reject:a}=gt(),c=Ke(),l=gs().toString(),h=this.client.session.get(i).namespaces;return this.events.once(J("session_update",c),({error:u})=>{u?a(u):o()}),await this.client.session.update(i,{namespaces:n}),await this.sendRequest({topic:i,method:"wc_sessionUpdate",params:{namespaces:n},throwOnFailedPublish:!0,clientRpcId:c,relayRpcId:l}).catch(u=>{this.client.logger.error(u),this.client.session.update(i,{namespaces:h}),a(u)}),{acknowledged:r}}),v(this,"extend",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(t)}catch(c){throw this.client.logger.error("extend() -> isValidExtend() failed"),c}const{topic:i}=t,n=Ke(),{done:r,resolve:o,reject:a}=gt();return this.events.once(J("session_extend",n),({error:c})=>{c?a(c):o()}),await this.setExpiry(i,we(Et)),this.sendRequest({topic:i,method:"wc_sessionExtend",params:{},clientRpcId:n,throwOnFailedPublish:!0}).catch(c=>{a(c)}),{acknowledged:r}}),v(this,"request",async t=>{this.isInitialized();try{await this.isValidRequest(t)}catch(m){throw this.client.logger.error("request() -> isValidRequest() failed"),m}const{chainId:i,request:n,topic:r,expiry:o=ce.wc_sessionRequest.req.ttl}=t,a=this.client.session.get(r);(a==null?void 0:a.transportType)===oe.relay&&await this.confirmOnlineStateOrThrow();const c=Ke(),l=gs().toString(),{done:h,resolve:u,reject:d}=gt(o,"Request expired. Please try again.");this.events.once(J("session_request",c),({error:m,result:g})=>{m?d(m):u(g)});const f="wc_sessionRequest",y=this.getAppLinkIfEnabled(a.peer.metadata,a.transportType);if(y)return await this.sendRequest({clientRpcId:c,relayRpcId:l,topic:r,method:f,params:{request:fe(Y({},n),{expiryTimestamp:we(o)}),chainId:i},expiry:o,throwOnFailedPublish:!0,appLink:y}).catch(m=>d(m)),this.client.events.emit("session_request_sent",{topic:r,request:n,chainId:i,id:c}),await h();const w={request:fe(Y({},n),{expiryTimestamp:we(o)}),chainId:i},p=this.shouldSetTVF(f,w);return await Promise.all([new Promise(async m=>{await this.sendRequest(Y({clientRpcId:c,relayRpcId:l,topic:r,method:f,params:w,expiry:o,throwOnFailedPublish:!0},p&&{tvf:this.getTVFParams(c,w)})).catch(g=>d(g)),this.client.events.emit("session_request_sent",{topic:r,request:n,chainId:i,id:c}),m()}),new Promise(async m=>{var g;if(!((g=a.sessionConfig)!=null&&g.disableDeepLink)){const I=await ec(this.client.core.storage,Hn);await Za({id:c,topic:r,wcDeepLink:I})}m()}),h()]).then(m=>m[2])}),v(this,"respond",async t=>{this.isInitialized(),await this.isValidRespond(t);const{topic:i,response:n}=t,{id:r}=n,o=this.client.session.get(i);o.transportType===oe.relay&&await this.confirmOnlineStateOrThrow();const a=this.getAppLinkIfEnabled(o.peer.metadata,o.transportType);Ge(n)?await this.sendResult({id:r,topic:i,result:n.result,throwOnFailedPublish:!0,appLink:a}):Je(n)&&await this.sendError({id:r,topic:i,error:n.error,appLink:a}),this.cleanupAfterResponse(t)}),v(this,"ping",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(t)}catch(n){throw this.client.logger.error("ping() -> isValidPing() failed"),n}const{topic:i}=t;if(this.client.session.keys.includes(i)){const n=Ke(),r=gs().toString(),{done:o,resolve:a,reject:c}=gt();this.events.once(J("session_ping",n),({error:l})=>{l?c(l):a()}),await Promise.all([this.sendRequest({topic:i,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:n,relayRpcId:r}),o()])}else this.client.core.pairing.pairings.keys.includes(i)&&(this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),await this.client.core.pairing.ping({topic:i}))}),v(this,"emit",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(t);const{topic:i,event:n,chainId:r}=t,o=gs().toString(),a=Ke();await this.sendRequest({topic:i,method:"wc_sessionEvent",params:{event:n,chainId:r},throwOnFailedPublish:!0,relayRpcId:o,clientRpcId:a})}),v(this,"disconnect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(t);const{topic:i}=t;if(this.client.session.keys.includes(i))await this.sendRequest({topic:i,method:"wc_sessionDelete",params:X("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:i,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(i))await this.client.core.pairing.disconnect({topic:i});else{const{message:n}=D("MISMATCHED_TOPIC",`Session or pairing topic not found: ${i}`);throw new Error(n)}}),v(this,"find",t=>(this.isInitialized(),this.client.session.getAll().filter(i=>Oh(i,t)))),v(this,"getPendingSessionRequests",()=>this.client.pendingRequest.getAll()),v(this,"authenticate",async(t,i)=>{var n;this.isInitialized(),this.isValidAuthenticate(t);const r=i&&this.client.core.linkModeSupportedApps.includes(i)&&((n=this.client.metadata.redirect)==null?void 0:n.linkMode),o=r?oe.link_mode:oe.relay;o===oe.relay&&await this.confirmOnlineStateOrThrow();const{chains:a,statement:c="",uri:l,domain:h,nonce:u,type:d,exp:f,nbf:y,methods:w=[],expiry:p}=t,m=[...t.resources||[]],{topic:g,uri:I}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:o});this.client.logger.info({message:"Generated new pairing",pairing:{topic:g,uri:I}});const _=await this.client.core.crypto.generateKeyPair(),T=ei(_);if(await Promise.all([this.client.auth.authKeys.set(Ts,{responseTopic:T,publicKey:_}),this.client.auth.pairingTopics.set(T,{topic:T,pairingTopic:g})]),await this.client.core.relayer.subscribe(T,{transportType:o}),this.client.logger.info(`sending request to new pairing topic: ${g}`),w.length>0){const{namespace:C}=Lt(a[0]);let j=Wc(C,"request",w);_s(m)&&(j=Gc(j,m.pop())),m.push(j)}const P=p&&p>ce.wc_sessionAuthenticate.req.ttl?p:ce.wc_sessionAuthenticate.req.ttl,O={authPayload:{type:d??"caip122",chains:a,statement:c,aud:l,domain:h,version:"1",nonce:u,iat:new Date().toISOString(),exp:f,nbf:y,resources:m},requester:{publicKey:_,metadata:this.client.metadata},expiryTimestamp:we(P)},$={eip155:{chains:a,methods:[...new Set(["personal_sign",...w])],events:["chainChanged","accountsChanged"]}},b={requiredNamespaces:{},optionalNamespaces:$,relays:[{protocol:"irn"}],pairingTopic:g,proposer:{publicKey:_,metadata:this.client.metadata},expiryTimestamp:we(ce.wc_sessionPropose.req.ttl),id:Ke()},{done:L,resolve:k,reject:x}=gt(P,"Request expired"),B=Ke(),E=J("session_connect",b.id),N=J("session_request",B),A=async({error:C,session:j})=>{this.events.off(N,R),C?x(C):j&&k({session:j})},R=async C=>{var j,M,H;if(await this.deletePendingAuthRequest(B,{message:"fulfilled",code:0}),C.error){const re=X("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return C.error.code===re.code?void 0:(this.events.off(E,A),x(C.error.message))}await this.deleteProposal(b.id),this.events.off(E,A);const{cacaos:Z,responder:G}=C.result,ie=[],ae=[];for(const re of Z){await wn({cacao:re,projectId:this.client.core.projectId})||(this.client.logger.error(re,"Signature verification failed"),x(X("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:st}=re,De=_s(st.resources),$e=[pi(st.iss)],Le=ks(st.iss);if(De){const je=mn(De),fs=yn(De);ie.push(...je),$e.push(...fs)}for(const je of $e)ae.push(`${je}:${Le}`)}const pe=await this.client.core.crypto.generateSharedKey(_,G.publicKey);let ne;ie.length>0&&(ne={topic:pe,acknowledged:!0,self:{publicKey:_,metadata:this.client.metadata},peer:G,controller:G.publicKey,expiry:we(Et),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:g,namespaces:Dn([...new Set(ie)],[...new Set(ae)]),transportType:o},await this.client.core.relayer.subscribe(pe,{transportType:o}),await this.client.session.set(pe,ne),g&&await this.client.core.pairing.updateMetadata({topic:g,metadata:G.metadata}),ne=this.client.session.get(pe)),(j=this.client.metadata.redirect)!=null&&j.linkMode&&(M=G.metadata.redirect)!=null&&M.linkMode&&(H=G.metadata.redirect)!=null&&H.universal&&i&&(this.client.core.addLinkModeSupportedApp(G.metadata.redirect.universal),this.client.session.update(pe,{transportType:oe.link_mode})),k({auths:Z,session:ne})};this.events.once(E,A),this.events.once(N,R);let q;try{if(r){const C=rs("wc_sessionAuthenticate",O,B);this.client.core.history.set(g,C);const j=await this.client.core.crypto.encode("",C,{type:ph,encoding:is});q=Is(i,g,j)}else await Promise.all([this.sendRequest({topic:g,method:"wc_sessionAuthenticate",params:O,expiry:t.expiry,throwOnFailedPublish:!0,clientRpcId:B}),this.sendRequest({topic:g,method:"wc_sessionPropose",params:b,expiry:ce.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:b.id})])}catch(C){throw this.events.off(E,A),this.events.off(N,R),C}return await this.setProposal(b.id,b),await this.setAuthRequest(B,{request:fe(Y({},O),{verifyContext:{}}),pairingTopic:g,transportType:o}),{uri:q??I,response:L}}),v(this,"approveSessionAuthenticate",async t=>{const{id:i,auths:n}=t,r=this.client.core.eventClient.createEvent({properties:{topic:i.toString(),trace:[nt.authenticated_session_approve_started]}});try{this.isInitialized()}catch(p){throw r.setError(Yt.no_internet_connection),p}const o=this.getPendingAuthRequest(i);if(!o)throw r.setError(Yt.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${i}`);const a=o.transportType||oe.relay;a===oe.relay&&await this.confirmOnlineStateOrThrow();const c=o.requester.publicKey,l=await this.client.core.crypto.generateKeyPair(),h=ei(c),u={type:Xs,receiverPublicKey:c,senderPublicKey:l},d=[],f=[];for(const p of n){if(!await wn({cacao:p,projectId:this.client.core.projectId})){r.setError(Yt.invalid_cacao);const T=X("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:i,topic:h,error:T,encodeOpts:u}),new Error(T.message)}r.addTrace(nt.cacaos_verified);const{p:m}=p,g=_s(m.resources),I=[pi(m.iss)],_=ks(m.iss);if(g){const T=mn(g),P=yn(g);d.push(...T),I.push(...P)}for(const T of I)f.push(`${T}:${_}`)}const y=await this.client.core.crypto.generateSharedKey(l,c);r.addTrace(nt.create_authenticated_session_topic);let w;if((d==null?void 0:d.length)>0){w={topic:y,acknowledged:!0,self:{publicKey:l,metadata:this.client.metadata},peer:{publicKey:c,metadata:o.requester.metadata},controller:c,expiry:we(Et),authentication:n,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:o.pairingTopic,namespaces:Dn([...new Set(d)],[...new Set(f)]),transportType:a},r.addTrace(nt.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(y,{transportType:a})}catch(p){throw r.setError(Yt.subscribe_authenticated_session_topic_failure),p}r.addTrace(nt.subscribe_authenticated_session_topic_success),await this.client.session.set(y,w),r.addTrace(nt.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:o.pairingTopic,metadata:o.requester.metadata})}r.addTrace(nt.publishing_authenticated_session_approve);try{await this.sendResult({topic:h,id:i,result:{cacaos:n,responder:{publicKey:l,metadata:this.client.metadata}},encodeOpts:u,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(o.requester.metadata,a)})}catch(p){throw r.setError(Yt.authenticated_session_approve_publish_failure),p}return await this.client.auth.requests.delete(i,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:o.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:r.eventId}),{session:w}}),v(this,"rejectSessionAuthenticate",async t=>{this.isInitialized();const{id:i,reason:n}=t,r=this.getPendingAuthRequest(i);if(!r)throw new Error(`Could not find pending auth request with id ${i}`);r.transportType===oe.relay&&await this.confirmOnlineStateOrThrow();const o=r.requester.publicKey,a=await this.client.core.crypto.generateKeyPair(),c=ei(o),l={type:Xs,receiverPublicKey:o,senderPublicKey:a};await this.sendError({id:i,topic:c,error:n,encodeOpts:l,rpcOpts:ce.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(r.requester.metadata,r.transportType)}),await this.client.auth.requests.delete(i,{message:"rejected",code:0}),await this.client.proposal.delete(i,X("USER_DISCONNECTED"))}),v(this,"formatAuthMessage",t=>{this.isInitialized();const{request:i,iss:n}=t;return Vr(i,n)}),v(this,"processRelayMessageCache",()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const t=this.relayMessageCache.shift();t&&await this.onRelayMessage(t)}catch(t){this.client.logger.error(t)}},50)}),v(this,"cleanupDuplicatePairings",async t=>{if(t.pairingTopic)try{const i=this.client.core.pairing.pairings.get(t.pairingTopic),n=this.client.core.pairing.pairings.getAll().filter(r=>{var o,a;return((o=r.peerMetadata)==null?void 0:o.url)&&((a=r.peerMetadata)==null?void 0:a.url)===t.peer.metadata.url&&r.topic&&r.topic!==i.topic});if(n.length===0)return;this.client.logger.info(`Cleaning up ${n.length} duplicate pairing(s)`),await Promise.all(n.map(r=>this.client.core.pairing.disconnect({topic:r.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(i){this.client.logger.error(i)}}),v(this,"deleteSession",async t=>{var i;const{topic:n,expirerHasDeleted:r=!1,emitEvent:o=!0,id:a=0}=t,{self:c}=this.client.session.get(n);await this.client.core.relayer.unsubscribe(n),await this.client.session.delete(n,X("USER_DISCONNECTED")),this.addToRecentlyDeleted(n,"session"),this.client.core.crypto.keychain.has(c.publicKey)&&await this.client.core.crypto.deleteKeyPair(c.publicKey),this.client.core.crypto.keychain.has(n)&&await this.client.core.crypto.deleteSymKey(n),r||this.client.core.expirer.del(n),this.client.core.storage.removeItem(Hn).catch(l=>this.client.logger.warn(l)),this.getPendingSessionRequests().forEach(l=>{l.topic===n&&this.deletePendingSessionRequest(l.id,X("USER_DISCONNECTED"))}),n===((i=this.sessionRequestQueue.queue[0])==null?void 0:i.topic)&&(this.sessionRequestQueue.state=qe.idle),o&&this.client.events.emit("session_delete",{id:a,topic:n})}),v(this,"deleteProposal",async(t,i)=>{if(i)try{const n=this.client.proposal.get(t),r=this.client.core.eventClient.getEvent({topic:n.pairingTopic});r==null||r.setError(it.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(t,X("USER_DISCONNECTED")),i?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")}),v(this,"deletePendingSessionRequest",async(t,i,n=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,i),n?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(r=>r.id!==t),n&&(this.sessionRequestQueue.state=qe.idle,this.client.events.emit("session_request_expire",{id:t}))}),v(this,"deletePendingAuthRequest",async(t,i,n=!1)=>{await Promise.all([this.client.auth.requests.delete(t,i),n?Promise.resolve():this.client.core.expirer.del(t)])}),v(this,"setExpiry",async(t,i)=>{this.client.session.keys.includes(t)&&(this.client.core.expirer.set(t,i),await this.client.session.update(t,{expiry:i}))}),v(this,"setProposal",async(t,i)=>{this.client.core.expirer.set(t,we(ce.wc_sessionPropose.req.ttl)),await this.client.proposal.set(t,i)}),v(this,"setAuthRequest",async(t,i)=>{const{request:n,pairingTopic:r,transportType:o=oe.relay}=i;this.client.core.expirer.set(t,n.expiryTimestamp),await this.client.auth.requests.set(t,{authPayload:n.authPayload,requester:n.requester,expiryTimestamp:n.expiryTimestamp,id:t,pairingTopic:r,verifyContext:n.verifyContext,transportType:o})}),v(this,"setPendingSessionRequest",async t=>{const{id:i,topic:n,params:r,verifyContext:o}=t,a=r.request.expiryTimestamp||we(ce.wc_sessionRequest.req.ttl);this.client.core.expirer.set(i,a),await this.client.pendingRequest.set(i,{id:i,topic:n,params:r,verifyContext:o})}),v(this,"sendRequest",async t=>{const{topic:i,method:n,params:r,expiry:o,relayRpcId:a,clientRpcId:c,throwOnFailedPublish:l,appLink:h,tvf:u}=t,d=rs(n,r,c);let f;const y=!!h;try{const m=y?is:bs;f=await this.client.core.crypto.encode(i,d,{encoding:m})}catch(m){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${i} failed`),m}let w;if(Qh.includes(n)){const m=vt(JSON.stringify(d)),g=vt(f);w=await this.client.core.verify.register({id:g,decryptedId:m})}const p=ce[n].req;if(p.attestation=w,o&&(p.ttl=o),a&&(p.id=a),this.client.core.history.set(i,d),y){const m=Is(h,i,f);await me.Linking.openURL(m,this.client.name)}else{const m=ce[n].req;o&&(m.ttl=o),a&&(m.id=a),m.tvf=fe(Y({},u),{correlationId:d.id}),l?(m.internal=fe(Y({},m.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(i,f,m)):this.client.core.relayer.publish(i,f,m).catch(g=>this.client.logger.error(g))}return d.id}),v(this,"sendResult",async t=>{const{id:i,topic:n,result:r,throwOnFailedPublish:o,encodeOpts:a,appLink:c}=t,l=pr(i,r);let h;const u=c&&typeof(me==null?void 0:me.Linking)<"u";try{const y=u?is:bs;h=await this.client.core.crypto.encode(n,l,fe(Y({},a||{}),{encoding:y}))}catch(y){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${n} failed`),y}let d,f;try{d=await this.client.core.history.get(n,i);const y=d.request;try{this.shouldSetTVF(y.method,y.params)&&(f=this.getTVFParams(i,y.params,r))}catch(w){this.client.logger.warn("sendResult() -> getTVFParams() failed",w)}}catch(y){throw this.client.logger.error(`sendResult() -> history.get(${n}, ${i}) failed`),y}if(u){const y=Is(c,n,h);await me.Linking.openURL(y,this.client.name)}else{const y=d.request.method,w=ce[y].res;w.tvf=fe(Y({},f),{correlationId:i}),o?(w.internal=fe(Y({},w.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(n,h,w)):this.client.core.relayer.publish(n,h,w).catch(p=>this.client.logger.error(p))}await this.client.core.history.resolve(l)}),v(this,"sendError",async t=>{const{id:i,topic:n,error:r,encodeOpts:o,rpcOpts:a,appLink:c}=t,l=Ro(i,r);let h;const u=c&&typeof(me==null?void 0:me.Linking)<"u";try{const f=u?is:bs;h=await this.client.core.crypto.encode(n,l,fe(Y({},o||{}),{encoding:f}))}catch(f){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${n} failed`),f}let d;try{d=await this.client.core.history.get(n,i)}catch(f){throw this.client.logger.error(`sendError() -> history.get(${n}, ${i}) failed`),f}if(u){const f=Is(c,n,h);await me.Linking.openURL(f,this.client.name)}else{const f=d.request.method,y=a||ce[f].res;this.client.core.relayer.publish(n,h,y)}await this.client.core.history.resolve(l)}),v(this,"cleanup",async()=>{const t=[],i=[];this.client.session.getAll().forEach(n=>{let r=!1;wt(n.expiry)&&(r=!0),this.client.core.crypto.keychain.has(n.topic)||(r=!0),r&&t.push(n.topic)}),this.client.proposal.getAll().forEach(n=>{wt(n.expiryTimestamp)&&i.push(n.id)}),await Promise.all([...t.map(n=>this.deleteSession({topic:n})),...i.map(n=>this.deleteProposal(n))])}),v(this,"onProviderMessageEvent",async t=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(t):await this.onRelayMessage(t)}),v(this,"onRelayEventRequest",async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()}),v(this,"processRequestsQueue",async()=>{if(this.requestQueue.state===qe.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=qe.active;const t=this.requestQueue.queue.shift();if(t)try{await this.processRequest(t)}catch(i){this.client.logger.warn(i)}}this.requestQueue.state=qe.idle}),v(this,"processRequest",async t=>{const{topic:i,payload:n,attestation:r,transportType:o,encryptedId:a}=t,c=n.method;if(!this.shouldIgnorePairingRequest({topic:i,requestMethod:c}))switch(c){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:i,payload:n,attestation:r,encryptedId:a});case"wc_sessionSettle":return await this.onSessionSettleRequest(i,n);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(i,n);case"wc_sessionExtend":return await this.onSessionExtendRequest(i,n);case"wc_sessionPing":return await this.onSessionPingRequest(i,n);case"wc_sessionDelete":return await this.onSessionDeleteRequest(i,n);case"wc_sessionRequest":return await this.onSessionRequest({topic:i,payload:n,attestation:r,encryptedId:a,transportType:o});case"wc_sessionEvent":return await this.onSessionEventRequest(i,n);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:i,payload:n,attestation:r,encryptedId:a,transportType:o});default:return this.client.logger.info(`Unsupported request method ${c}`)}}),v(this,"onRelayEventResponse",async t=>{const{topic:i,payload:n,transportType:r}=t,o=(await this.client.core.history.get(i,n.id)).request.method;switch(o){case"wc_sessionPropose":return this.onSessionProposeResponse(i,n,r);case"wc_sessionSettle":return this.onSessionSettleResponse(i,n);case"wc_sessionUpdate":return this.onSessionUpdateResponse(i,n);case"wc_sessionExtend":return this.onSessionExtendResponse(i,n);case"wc_sessionPing":return this.onSessionPingResponse(i,n);case"wc_sessionRequest":return this.onSessionRequestResponse(i,n);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(i,n);default:return this.client.logger.info(`Unsupported response method ${o}`)}}),v(this,"onRelayEventUnknownPayload",t=>{const{topic:i}=t,{message:n}=D("MISSING_OR_INVALID",`Decoded payload on topic ${i} is not identifiable as a JSON-RPC request or a response.`);throw new Error(n)}),v(this,"shouldIgnorePairingRequest",t=>{const{topic:i,requestMethod:n}=t,r=this.expectedPairingMethodMap.get(i);return!r||r.includes(n)?!1:!!(r.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)}),v(this,"onSessionProposeRequest",async t=>{const{topic:i,payload:n,attestation:r,encryptedId:o}=t,{params:a,id:c}=n;try{const l=this.client.core.eventClient.getEvent({topic:i});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),l==null||l.setError(Do.proposal_listener_not_found)),this.isValidConnect(Y({},n.params));const h=a.expiryTimestamp||we(ce.wc_sessionPropose.req.ttl),u=Y({id:c,pairingTopic:i,expiryTimestamp:h},a);await this.setProposal(c,u);const d=await this.getVerifyContext({attestationId:r,hash:vt(JSON.stringify(n)),encryptedId:o,metadata:u.proposer.metadata});l==null||l.addTrace(Lo.emit_session_proposal),this.client.events.emit("session_proposal",{id:c,params:u,verifyContext:d})}catch(l){await this.sendError({id:c,topic:i,error:l,rpcOpts:ce.wc_sessionPropose.autoReject}),this.client.logger.error(l)}}),v(this,"onSessionProposeResponse",async(t,i,n)=>{const{id:r}=i;if(Ge(i)){const{result:o}=i;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:o});const a=this.client.proposal.get(r);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:a});const c=a.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:c});const l=o.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:l});const h=await this.client.core.crypto.generateSharedKey(c,l);this.pendingSessions.set(r,{sessionTopic:h,pairingTopic:t,proposalId:r,publicKey:c});const u=await this.client.core.relayer.subscribe(h,{transportType:n});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:u}),await this.client.core.pairing.activate({topic:t})}else if(Je(i)){await this.client.proposal.delete(r,X("USER_DISCONNECTED"));const o=J("session_connect",r);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners, 954`);this.events.emit(o,{error:i.error})}}),v(this,"onSessionSettleRequest",async(t,i)=>{const{id:n,params:r}=i;try{this.isValidSessionSettleRequest(r);const{relay:o,controller:a,expiry:c,namespaces:l,sessionProperties:h,scopedProperties:u,sessionConfig:d}=i.params,f=[...this.pendingSessions.values()].find(p=>p.sessionTopic===t);if(!f)return this.client.logger.error(`Pending session not found for topic ${t}`);const y=this.client.proposal.get(f.proposalId),w=fe(Y(Y(Y({topic:t,relay:o,expiry:c,namespaces:l,acknowledged:!0,pairingTopic:f.pairingTopic,requiredNamespaces:y.requiredNamespaces,optionalNamespaces:y.optionalNamespaces,controller:a.publicKey,self:{publicKey:f.publicKey,metadata:this.client.metadata},peer:{publicKey:a.publicKey,metadata:a.metadata}},h&&{sessionProperties:h}),u&&{scopedProperties:u}),d&&{sessionConfig:d}),{transportType:oe.relay});await this.client.session.set(w.topic,w),await this.setExpiry(w.topic,w.expiry),await this.client.core.pairing.updateMetadata({topic:f.pairingTopic,metadata:w.peer.metadata}),this.client.events.emit("session_connect",{session:w}),this.events.emit(J("session_connect",f.proposalId),{session:w}),this.pendingSessions.delete(f.proposalId),this.deleteProposal(f.proposalId,!1),this.cleanupDuplicatePairings(w),await this.sendResult({id:i.id,topic:t,result:!0,throwOnFailedPublish:!0})}catch(o){await this.sendError({id:n,topic:t,error:o}),this.client.logger.error(o)}}),v(this,"onSessionSettleResponse",async(t,i)=>{const{id:n}=i;Ge(i)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit(J("session_approve",n),{})):Je(i)&&(await this.client.session.delete(t,X("USER_DISCONNECTED")),this.events.emit(J("session_approve",n),{error:i.error}))}),v(this,"onSessionUpdateRequest",async(t,i)=>{const{params:n,id:r}=i;try{const o=`${t}_session_update`,a=ns.get(o);if(a&&this.isRequestOutOfSync(a,r)){this.client.logger.warn(`Discarding out of sync request - ${r}`),this.sendError({id:r,topic:t,error:X("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(Y({topic:t},n));try{ns.set(o,r),await this.client.session.update(t,{namespaces:n.namespaces}),await this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0})}catch(c){throw ns.delete(o),c}this.client.events.emit("session_update",{id:r,topic:t,params:n})}catch(o){await this.sendError({id:r,topic:t,error:o}),this.client.logger.error(o)}}),v(this,"isRequestOutOfSync",(t,i)=>i.toString().slice(0,-3)<t.toString().slice(0,-3)),v(this,"onSessionUpdateResponse",(t,i)=>{const{id:n}=i,r=J("session_update",n);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);Ge(i)?this.events.emit(J("session_update",n),{}):Je(i)&&this.events.emit(J("session_update",n),{error:i.error})}),v(this,"onSessionExtendRequest",async(t,i)=>{const{id:n}=i;try{this.isValidExtend({topic:t}),await this.setExpiry(t,we(Et)),await this.sendResult({id:n,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:n,topic:t})}catch(r){await this.sendError({id:n,topic:t,error:r}),this.client.logger.error(r)}}),v(this,"onSessionExtendResponse",(t,i)=>{const{id:n}=i,r=J("session_extend",n);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);Ge(i)?this.events.emit(J("session_extend",n),{}):Je(i)&&this.events.emit(J("session_extend",n),{error:i.error})}),v(this,"onSessionPingRequest",async(t,i)=>{const{id:n}=i;try{this.isValidPing({topic:t}),await this.sendResult({id:n,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:n,topic:t})}catch(r){await this.sendError({id:n,topic:t,error:r}),this.client.logger.error(r)}}),v(this,"onSessionPingResponse",(t,i)=>{const{id:n}=i,r=J("session_ping",n);setTimeout(()=>{if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners 2176`);Ge(i)?this.events.emit(J("session_ping",n),{}):Je(i)&&this.events.emit(J("session_ping",n),{error:i.error})},500)}),v(this,"onSessionDeleteRequest",async(t,i)=>{const{id:n}=i;try{this.isValidDisconnect({topic:t,reason:i.params}),Promise.all([new Promise(r=>{this.client.core.relayer.once(Hi.publish,async()=>{r(await this.deleteSession({topic:t,id:n}))})}),this.sendResult({id:n,topic:t,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:X("USER_DISCONNECTED")})]).catch(r=>this.client.logger.error(r))}catch(r){this.client.logger.error(r)}}),v(this,"onSessionRequest",async t=>{var i,n,r;const{topic:o,payload:a,attestation:c,encryptedId:l,transportType:h}=t,{id:u,params:d}=a;try{await this.isValidRequest(Y({topic:o},d));const f=this.client.session.get(o),y=await this.getVerifyContext({attestationId:c,hash:vt(JSON.stringify(rs("wc_sessionRequest",d,u))),encryptedId:l,metadata:f.peer.metadata,transportType:h}),w={id:u,topic:o,params:d,verifyContext:y};await this.setPendingSessionRequest(w),h===oe.link_mode&&(i=f.peer.metadata.redirect)!=null&&i.universal&&this.client.core.addLinkModeSupportedApp((n=f.peer.metadata.redirect)==null?void 0:n.universal),(r=this.client.signConfig)!=null&&r.disableRequestQueue?this.emitSessionRequest(w):(this.addSessionRequestToSessionRequestQueue(w),this.processSessionRequestQueue())}catch(f){await this.sendError({id:u,topic:o,error:f}),this.client.logger.error(f)}}),v(this,"onSessionRequestResponse",(t,i)=>{const{id:n}=i,r=J("session_request",n);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);Ge(i)?this.events.emit(J("session_request",n),{result:i.result}):Je(i)&&this.events.emit(J("session_request",n),{error:i.error})}),v(this,"onSessionEventRequest",async(t,i)=>{const{id:n,params:r}=i;try{const o=`${t}_session_event_${r.event.name}`,a=ns.get(o);if(a&&this.isRequestOutOfSync(a,n)){this.client.logger.info(`Discarding out of sync request - ${n}`);return}this.isValidEmit(Y({topic:t},r)),this.client.events.emit("session_event",{id:n,topic:t,params:r}),ns.set(o,n)}catch(o){await this.sendError({id:n,topic:t,error:o}),this.client.logger.error(o)}}),v(this,"onSessionAuthenticateResponse",(t,i)=>{const{id:n}=i;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:t,payload:i}),Ge(i)?this.events.emit(J("session_request",n),{result:i.result}):Je(i)&&this.events.emit(J("session_request",n),{error:i.error})}),v(this,"onSessionAuthenticateRequest",async t=>{var i;const{topic:n,payload:r,attestation:o,encryptedId:a,transportType:c}=t;try{const{requester:l,authPayload:h,expiryTimestamp:u}=r.params,d=await this.getVerifyContext({attestationId:o,hash:vt(JSON.stringify(r)),encryptedId:a,metadata:l.metadata,transportType:c}),f={requester:l,pairingTopic:n,id:r.id,authPayload:h,verifyContext:d,expiryTimestamp:u};await this.setAuthRequest(r.id,{request:f,pairingTopic:n,transportType:c}),c===oe.link_mode&&(i=l.metadata.redirect)!=null&&i.universal&&this.client.core.addLinkModeSupportedApp(l.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:n,params:r.params,id:r.id,verifyContext:d})}catch(l){this.client.logger.error(l);const h=r.params.requester.publicKey,u=await this.client.core.crypto.generateKeyPair(),d=this.getAppLinkIfEnabled(r.params.requester.metadata,c),f={type:Xs,receiverPublicKey:h,senderPublicKey:u};await this.sendError({id:r.id,topic:n,error:l,encodeOpts:f,rpcOpts:ce.wc_sessionAuthenticate.autoReject,appLink:d})}}),v(this,"addSessionRequestToSessionRequestQueue",t=>{this.sessionRequestQueue.queue.push(t)}),v(this,"cleanupAfterResponse",t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=qe.idle,this.processSessionRequestQueue()},F.toMiliseconds(this.requestQueueDelay))}),v(this,"cleanupPendingSentRequestsForTopic",({topic:t,error:i})=>{const n=this.client.core.history.pending;n.length>0&&n.filter(r=>r.topic===t&&r.request.method==="wc_sessionRequest").forEach(r=>{const o=r.request.id,a=J("session_request",o);if(this.events.listenerCount(a)===0)throw new Error(`emitting ${a} without any listeners`);this.events.emit(J("session_request",r.request.id),{error:i})})}),v(this,"processSessionRequestQueue",()=>{if(this.sessionRequestQueue.state===qe.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=qe.active,this.emitSessionRequest(t)}catch(i){this.client.logger.error(i)}}),v(this,"emitSessionRequest",t=>{this.client.events.emit("session_request",t)}),v(this,"onPairingCreated",t=>{if(t.methods&&this.expectedPairingMethodMap.set(t.topic,t.methods),t.active)return;const i=this.client.proposal.getAll().find(n=>n.pairingTopic===t.topic);i&&this.onSessionProposeRequest({topic:t.topic,payload:rs("wc_sessionPropose",fe(Y({},i),{requiredNamespaces:i.requiredNamespaces,optionalNamespaces:i.optionalNamespaces,relays:i.relays,proposer:i.proposer,sessionProperties:i.sessionProperties,scopedProperties:i.scopedProperties}),i.id)})}),v(this,"isValidConnect",async t=>{if(!Se(t)){const{message:l}=D("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(l)}const{pairingTopic:i,requiredNamespaces:n,optionalNamespaces:r,sessionProperties:o,scopedProperties:a,relays:c}=t;if(Ee(i)||await this.isValidPairingTopic(i),!Dh(c)){const{message:l}=D("MISSING_OR_INVALID",`connect() relays: ${c}`);throw new Error(l)}if(!Ee(n)&&tt(n)!==0){const l="requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";["fatal","error","silent"].includes(this.client.logger.level)?console.warn(l):this.client.logger.warn(l),this.validateNamespaces(n,"requiredNamespaces")}if(!Ee(r)&&tt(r)!==0&&this.validateNamespaces(r,"optionalNamespaces"),Ee(o)||this.validateSessionProps(o,"sessionProperties"),!Ee(a)){this.validateSessionProps(a,"scopedProperties");const l=Object.keys(n||{}).concat(Object.keys(r||{}));if(!Object.keys(a).every(h=>l.includes(h)))throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(a)}, required/optional namespaces: ${JSON.stringify(l)}`)}}),v(this,"validateNamespaces",(t,i)=>{const n=Uh(t,"connect()",i);if(n)throw new Error(n.message)}),v(this,"isValidApprove",async t=>{if(!Se(t))throw new Error(D("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:i,namespaces:n,relayProtocol:r,sessionProperties:o,scopedProperties:a}=t;this.checkRecentlyDeleted(i),await this.isValidProposalId(i);const c=this.client.proposal.get(i),l=ti(n,"approve()");if(l)throw new Error(l.message);const h=Bn(c.requiredNamespaces,n,"approve()");if(h)throw new Error(h.message);if(!he(r,!0)){const{message:u}=D("MISSING_OR_INVALID",`approve() relayProtocol: ${r}`);throw new Error(u)}if(Ee(o)||this.validateSessionProps(o,"sessionProperties"),!Ee(a)){this.validateSessionProps(a,"scopedProperties");const u=new Set(Object.keys(n));if(!Object.keys(a).every(d=>u.has(d)))throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(a)}, approved namespaces: ${Array.from(u).join(", ")}`)}}),v(this,"isValidReject",async t=>{if(!Se(t)){const{message:r}=D("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(r)}const{id:i,reason:n}=t;if(this.checkRecentlyDeleted(i),await this.isValidProposalId(i),!jh(n)){const{message:r}=D("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(n)}`);throw new Error(r)}}),v(this,"isValidSessionSettleRequest",t=>{if(!Se(t)){const{message:l}=D("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(l)}const{relay:i,controller:n,namespaces:r,expiry:o}=t;if(!lo(i)){const{message:l}=D("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const a=Th(n,"onSessionSettleRequest()");if(a)throw new Error(a.message);const c=ti(r,"onSessionSettleRequest()");if(c)throw new Error(c.message);if(wt(o)){const{message:l}=D("EXPIRED","onSessionSettleRequest()");throw new Error(l)}}),v(this,"isValidUpdate",async t=>{if(!Se(t)){const{message:c}=D("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(c)}const{topic:i,namespaces:n}=t;this.checkRecentlyDeleted(i),await this.isValidSessionTopic(i);const r=this.client.session.get(i),o=ti(n,"update()");if(o)throw new Error(o.message);const a=Bn(r.requiredNamespaces,n,"update()");if(a)throw new Error(a.message)}),v(this,"isValidExtend",async t=>{if(!Se(t)){const{message:n}=D("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(n)}const{topic:i}=t;this.checkRecentlyDeleted(i),await this.isValidSessionTopic(i)}),v(this,"isValidRequest",async t=>{if(!Se(t)){const{message:c}=D("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(c)}const{topic:i,request:n,chainId:r,expiry:o}=t;this.checkRecentlyDeleted(i),await this.isValidSessionTopic(i);const{namespaces:a}=this.client.session.get(i);if(!jn(a,r)){const{message:c}=D("MISSING_OR_INVALID",`request() chainId: ${r}`);throw new Error(c)}if(!Bh(n)){const{message:c}=D("MISSING_OR_INVALID",`request() ${JSON.stringify(n)}`);throw new Error(c)}if(!Fh(a,r,n.method)){const{message:c}=D("MISSING_OR_INVALID",`request() method: ${n.method}`);throw new Error(c)}if(o&&!Kh(o,ni)){const{message:c}=D("MISSING_OR_INVALID",`request() expiry: ${o}. Expiry must be a number (in seconds) between ${ni.min} and ${ni.max}`);throw new Error(c)}}),v(this,"isValidRespond",async t=>{var i;if(!Se(t)){const{message:o}=D("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(o)}const{topic:n,response:r}=t;try{await this.isValidSessionTopic(n)}catch(o){throw(i=t==null?void 0:t.response)!=null&&i.id&&this.cleanupAfterResponse(t),o}if(!Mh(r)){const{message:o}=D("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(r)}`);throw new Error(o)}}),v(this,"isValidPing",async t=>{if(!Se(t)){const{message:n}=D("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(n)}const{topic:i}=t;await this.isValidSessionOrPairingTopic(i)}),v(this,"isValidEmit",async t=>{if(!Se(t)){const{message:a}=D("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(a)}const{topic:i,event:n,chainId:r}=t;await this.isValidSessionTopic(i);const{namespaces:o}=this.client.session.get(i);if(!jn(o,r)){const{message:a}=D("MISSING_OR_INVALID",`emit() chainId: ${r}`);throw new Error(a)}if(!Hh(n)){const{message:a}=D("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(n)}`);throw new Error(a)}if(!Vh(o,r,n.name)){const{message:a}=D("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(n)}`);throw new Error(a)}}),v(this,"isValidDisconnect",async t=>{if(!Se(t)){const{message:n}=D("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(n)}const{topic:i}=t;await this.isValidSessionOrPairingTopic(i)}),v(this,"isValidAuthenticate",t=>{const{chains:i,uri:n,domain:r,nonce:o}=t;if(!Array.isArray(i)||i.length===0)throw new Error("chains is required and must be a non-empty array");if(!he(n,!1))throw new Error("uri is required parameter");if(!he(r,!1))throw new Error("domain is required parameter");if(!he(o,!1))throw new Error("nonce is required parameter");if([...new Set(i.map(c=>Lt(c).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:a}=Lt(i[0]);if(a!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")}),v(this,"getVerifyContext",async t=>{const{attestationId:i,hash:n,encryptedId:r,metadata:o,transportType:a}=t,c={verified:{verifyUrl:o.verifyUrl||jo,validation:"UNKNOWN",origin:o.url||""}};try{if(a===oe.link_mode){const h=this.getAppLinkIfEnabled(o,a);return c.verified.validation=h&&new URL(h).origin===new URL(o.url).origin?"VALID":"INVALID",c}const l=await this.client.core.verify.resolve({attestationId:i,hash:n,encryptedId:r,verifyUrl:o.verifyUrl});l&&(c.verified.origin=l.origin,c.verified.isScam=l.isScam,c.verified.validation=l.origin===new URL(o.url).origin?"VALID":"INVALID")}catch(l){this.client.logger.warn(l)}return this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`),c}),v(this,"validateSessionProps",(t,i)=>{Object.values(t).forEach((n,r)=>{if(n==null){const{message:o}=D("MISSING_OR_INVALID",`${i} must contain an existing value for each key. Received: ${n} for key ${Object.keys(t)[r]}`);throw new Error(o)}})}),v(this,"getPendingAuthRequest",t=>{const i=this.client.auth.requests.get(t);return typeof i=="object"?i:void 0}),v(this,"addToRecentlyDeleted",(t,i)=>{if(this.recentlyDeletedMap.set(t,i),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let n=0;const r=this.recentlyDeletedLimit/2;for(const o of this.recentlyDeletedMap.keys()){if(n++>=r)break;this.recentlyDeletedMap.delete(o)}}}),v(this,"checkRecentlyDeleted",t=>{const i=this.recentlyDeletedMap.get(t);if(i){const{message:n}=D("MISSING_OR_INVALID",`Record was recently deleted - ${i}: ${t}`);throw new Error(n)}}),v(this,"isLinkModeEnabled",(t,i)=>{var n,r,o,a,c,l,h,u,d;return!t||i!==oe.link_mode?!1:((r=(n=this.client.metadata)==null?void 0:n.redirect)==null?void 0:r.linkMode)===!0&&((a=(o=this.client.metadata)==null?void 0:o.redirect)==null?void 0:a.universal)!==void 0&&((l=(c=this.client.metadata)==null?void 0:c.redirect)==null?void 0:l.universal)!==""&&((h=t==null?void 0:t.redirect)==null?void 0:h.universal)!==void 0&&((u=t==null?void 0:t.redirect)==null?void 0:u.universal)!==""&&((d=t==null?void 0:t.redirect)==null?void 0:d.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(t.redirect.universal)&&typeof(me==null?void 0:me.Linking)<"u"}),v(this,"getAppLinkIfEnabled",(t,i)=>{var n;return this.isLinkModeEnabled(t,i)?(n=t==null?void 0:t.redirect)==null?void 0:n.universal:void 0}),v(this,"handleLinkModeMessage",({url:t})=>{if(!t||!t.includes("wc_ev")||!t.includes("topic"))return;const i=cn(t,"topic")||"",n=decodeURIComponent(cn(t,"wc_ev")||""),r=this.client.session.keys.includes(i);r&&this.client.session.update(i,{transportType:oe.link_mode}),this.client.core.dispatchEnvelope({topic:i,message:n,sessionExists:r})}),v(this,"registerLinkModeListeners",async()=>{var t;if(tc()||xr()&&(t=this.client.metadata.redirect)!=null&&t.linkMode){const i=me==null?void 0:me.Linking;if(typeof i<"u"){i.addEventListener("url",this.handleLinkModeMessage,this.client.name);const n=await i.getInitialURL();n&&setTimeout(()=>{this.handleLinkModeMessage({url:n})},50)}}}),v(this,"shouldSetTVF",(t,i)=>{if(!i||t!=="wc_sessionRequest")return!1;const{request:n}=i;return Object.keys(Vn).includes(n.method)}),v(this,"getTVFParams",(t,i,n)=>{var r,o;try{const a=i.request.method,c=this.extractTxHashesFromResult(a,n);return fe(Y({correlationId:t,rpcMethods:[a],chainId:i.chainId},this.isValidContractData(i.request.params)&&{contractAddresses:[(o=(r=i.request.params)==null?void 0:r[0])==null?void 0:o.to]}),{txHashes:c})}catch(a){this.client.logger.warn("Error getting TVF params",a)}return{}}),v(this,"isValidContractData",t=>{var i;if(!t)return!1;try{const n=(t==null?void 0:t.data)||((i=t==null?void 0:t[0])==null?void 0:i.data);if(!n.startsWith("0x"))return!1;const r=n.slice(2);return/^[0-9a-fA-F]*$/.test(r)?r.length%2===0:!1}catch{}return!1}),v(this,"extractTxHashesFromResult",(t,i)=>{try{const n=Vn[t];if(typeof i=="string")return[i];const r=i[n.key];if(et(r))return t==="solana_signAllTransactions"?r.map(o=>$c(o)):r;if(typeof r=="string")return[r]}catch(n){this.client.logger.warn("Error extracting tx hashes from result",n)}return[]})}async processPendingMessageEvents(){try{const e=this.client.session.keys,t=this.client.core.relayer.messages.getWithoutAck(e);for(const[i,n]of Object.entries(t))for(const r of n)try{await this.onProviderMessageEvent({topic:i,message:r,publishedAt:Date.now()})}catch{this.client.logger.warn(`Error processing pending message event for topic: ${i}, message: ${r}`)}}catch(e){this.client.logger.warn("processPendingMessageEvents failed",e)}}isInitialized(){if(!this.initialized){const{message:e}=D("NOT_INITIALIZED",this.name);throw new Error(e)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(Hi.message,e=>{this.onProviderMessageEvent(e)})}async onRelayMessage(e){const{topic:t,message:i,attestation:n,transportType:r}=e,{publicKey:o}=this.client.auth.authKeys.keys.includes(Ts)?this.client.auth.authKeys.get(Ts):{publicKey:void 0};try{const a=await this.client.core.crypto.decode(t,i,{receiverPublicKey:o,encoding:r===oe.link_mode?is:bs});_o(a)?(this.client.core.history.set(t,a),await this.onRelayEventRequest({topic:t,payload:a,attestation:n,transportType:r,encryptedId:vt(i)})):To(a)?(await this.client.core.history.resolve(a),await this.onRelayEventResponse({topic:t,payload:a,transportType:r}),this.client.core.history.delete(t,a.id)):await this.onRelayEventUnknownPayload({topic:t,payload:a,transportType:r}),await this.client.core.relayer.messages.ack(t,i)}catch(a){this.client.logger.error(a)}}registerExpirerEvents(){this.client.core.expirer.on(xo.expired,async e=>{const{topic:t,id:i}=Ya(e.target);if(i&&this.client.pendingRequest.keys.includes(i))return await this.deletePendingSessionRequest(i,D("EXPIRED"),!0);if(i&&this.client.auth.requests.keys.includes(i))return await this.deletePendingAuthRequest(i,D("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):i&&(await this.deleteProposal(i,!0),this.client.events.emit("proposal_expire",{id:i}))})}registerPairingEvents(){this.client.core.pairing.events.on(Fi.create,e=>this.onPairingCreated(e)),this.client.core.pairing.events.on(Fi.delete,e=>{this.addToRecentlyDeleted(e.topic,"pairing")})}isValidPairingTopic(e){if(!he(e,!1)){const{message:t}=D("MISSING_OR_INVALID",`pairing topic should be a string: ${e}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(e)){const{message:t}=D("NO_MATCHING_KEY",`pairing topic doesn't exist: ${e}`);throw new Error(t)}if(wt(this.client.core.pairing.pairings.get(e).expiry)){const{message:t}=D("EXPIRED",`pairing topic: ${e}`);throw new Error(t)}}async isValidSessionTopic(e){if(!he(e,!1)){const{message:t}=D("MISSING_OR_INVALID",`session topic should be a string: ${e}`);throw new Error(t)}if(this.checkRecentlyDeleted(e),!this.client.session.keys.includes(e)){const{message:t}=D("NO_MATCHING_KEY",`session topic doesn't exist: ${e}`);throw new Error(t)}if(wt(this.client.session.get(e).expiry)){await this.deleteSession({topic:e});const{message:t}=D("EXPIRED",`session topic: ${e}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(e)){const{message:t}=D("MISSING_OR_INVALID",`session topic does not exist in keychain: ${e}`);throw await this.deleteSession({topic:e}),new Error(t)}}async isValidSessionOrPairingTopic(e){if(this.checkRecentlyDeleted(e),this.client.session.keys.includes(e))await this.isValidSessionTopic(e);else if(this.client.core.pairing.pairings.keys.includes(e))this.isValidPairingTopic(e);else if(he(e,!1)){const{message:t}=D("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${e}`);throw new Error(t)}else{const{message:t}=D("MISSING_OR_INVALID",`session or pairing topic should be a string: ${e}`);throw new Error(t)}}async isValidProposalId(e){if(!Lh(e)){const{message:t}=D("MISSING_OR_INVALID",`proposal id should be a number: ${e}`);throw new Error(t)}if(!this.client.proposal.keys.includes(e)){const{message:t}=D("NO_MATCHING_KEY",`proposal id doesn't exist: ${e}`);throw new Error(t)}if(wt(this.client.proposal.get(e).expiryTimestamp)){await this.deleteProposal(e);const{message:t}=D("EXPIRED",`proposal id: ${e}`);throw new Error(t)}}}class hu extends zt{constructor(e,t){super(e,t,Gh,Ui),this.core=e,this.logger=t}}let uu=class extends zt{constructor(e,t){super(e,t,Jh,Ui),this.core=e,this.logger=t}};class du extends zt{constructor(e,t){super(e,t,Zh,Ui,i=>i.id),this.core=e,this.logger=t}}class pu extends zt{constructor(e,t){super(e,t,tu,Ms,()=>Ts),this.core=e,this.logger=t}}class fu extends zt{constructor(e,t){super(e,t,su,Ms),this.core=e,this.logger=t}}class gu extends zt{constructor(e,t){super(e,t,iu,Ms,i=>i.id),this.core=e,this.logger=t}}var wu=Object.defineProperty,mu=(s,e,t)=>e in s?wu(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,ri=(s,e,t)=>mu(s,typeof e!="symbol"?e+"":e,t);class yu{constructor(e,t){this.core=e,this.logger=t,ri(this,"authKeys"),ri(this,"pairingTopics"),ri(this,"requests"),this.authKeys=new pu(this.core,this.logger),this.pairingTopics=new fu(this.core,this.logger),this.requests=new gu(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}var vu=Object.defineProperty,Eu=(s,e,t)=>e in s?vu(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,V=(s,e,t)=>Eu(s,typeof e!="symbol"?e+"":e,t);let bu=class fo extends $o{constructor(e){super(e),V(this,"protocol",ho),V(this,"version",uo),V(this,"name",ii.name),V(this,"metadata"),V(this,"core"),V(this,"logger"),V(this,"events",new Po.EventEmitter),V(this,"engine"),V(this,"session"),V(this,"proposal"),V(this,"pendingRequest"),V(this,"auth"),V(this,"signConfig"),V(this,"on",(i,n)=>this.events.on(i,n)),V(this,"once",(i,n)=>this.events.once(i,n)),V(this,"off",(i,n)=>this.events.off(i,n)),V(this,"removeListener",(i,n)=>this.events.removeListener(i,n)),V(this,"removeAllListeners",i=>this.events.removeAllListeners(i)),V(this,"connect",async i=>{try{return await this.engine.connect(i)}catch(n){throw this.logger.error(n.message),n}}),V(this,"pair",async i=>{try{return await this.engine.pair(i)}catch(n){throw this.logger.error(n.message),n}}),V(this,"approve",async i=>{try{return await this.engine.approve(i)}catch(n){throw this.logger.error(n.message),n}}),V(this,"reject",async i=>{try{return await this.engine.reject(i)}catch(n){throw this.logger.error(n.message),n}}),V(this,"update",async i=>{try{return await this.engine.update(i)}catch(n){throw this.logger.error(n.message),n}}),V(this,"extend",async i=>{try{return await this.engine.extend(i)}catch(n){throw this.logger.error(n.message),n}}),V(this,"request",async i=>{try{return await this.engine.request(i)}catch(n){throw this.logger.error(n.message),n}}),V(this,"respond",async i=>{try{return await this.engine.respond(i)}catch(n){throw this.logger.error(n.message),n}}),V(this,"ping",async i=>{try{return await this.engine.ping(i)}catch(n){throw this.logger.error(n.message),n}}),V(this,"emit",async i=>{try{return await this.engine.emit(i)}catch(n){throw this.logger.error(n.message),n}}),V(this,"disconnect",async i=>{try{return await this.engine.disconnect(i)}catch(n){throw this.logger.error(n.message),n}}),V(this,"find",i=>{try{return this.engine.find(i)}catch(n){throw this.logger.error(n.message),n}}),V(this,"getPendingSessionRequests",()=>{try{return this.engine.getPendingSessionRequests()}catch(i){throw this.logger.error(i.message),i}}),V(this,"authenticate",async(i,n)=>{try{return await this.engine.authenticate(i,n)}catch(r){throw this.logger.error(r.message),r}}),V(this,"formatAuthMessage",i=>{try{return this.engine.formatAuthMessage(i)}catch(n){throw this.logger.error(n.message),n}}),V(this,"approveSessionAuthenticate",async i=>{try{return await this.engine.approveSessionAuthenticate(i)}catch(n){throw this.logger.error(n.message),n}}),V(this,"rejectSessionAuthenticate",async i=>{try{return await this.engine.rejectSessionAuthenticate(i)}catch(n){throw this.logger.error(n.message),n}}),this.name=(e==null?void 0:e.name)||ii.name,this.metadata=Ga(e==null?void 0:e.metadata),this.signConfig=e==null?void 0:e.signConfig;const t=typeof(e==null?void 0:e.logger)<"u"&&typeof(e==null?void 0:e.logger)!="string"?e.logger:hr(ur({level:(e==null?void 0:e.logger)||ii.logger}));this.core=(e==null?void 0:e.core)||new ko(e),this.logger=So(t,this.name),this.session=new uu(this.core,this.logger),this.proposal=new hu(this.core,this.logger),this.pendingRequest=new du(this.core,this.logger),this.engine=new lu(this),this.auth=new yu(this.core,this.logger)}static async init(e){const t=new fo(e);return await t.initialize(),t}get context(){return Oo(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success"),setTimeout(()=>{this.engine.processRelayMessageCache()},F.toMiliseconds(F.ONE_SECOND))}catch(e){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(e.message),e}}};const Wn="error",Iu="wss://relay.walletconnect.org",Cu="wc",Au="universal_provider",Cs=`${Cu}@2:${Au}:`,go="https://rpc.walletconnect.org/v1/",kt="generic",Nu=`${go}bundler`,Ne={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};function Pu(){}function Di(s){return s==null||typeof s!="object"&&typeof s!="function"}function Li(s){return ArrayBuffer.isView(s)&&!(s instanceof DataView)}function Su(s){if(Di(s))return s;if(Array.isArray(s)||Li(s)||s instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&s instanceof SharedArrayBuffer)return s.slice(0);const e=Object.getPrototypeOf(s),t=e.constructor;if(s instanceof Date||s instanceof Map||s instanceof Set)return new t(s);if(s instanceof RegExp){const i=new t(s);return i.lastIndex=s.lastIndex,i}if(s instanceof DataView)return new t(s.buffer.slice(0));if(s instanceof Error){const i=new t(s.message);return i.stack=s.stack,i.name=s.name,i.cause=s.cause,i}if(typeof File<"u"&&s instanceof File)return new t([s],s.name,{type:s.type,lastModified:s.lastModified});if(typeof s=="object"){const i=Object.create(e);return Object.assign(i,s)}return s}function Kn(s){return typeof s=="object"&&s!==null}function wo(s){return Object.getOwnPropertySymbols(s).filter(e=>Object.prototype.propertyIsEnumerable.call(s,e))}function mo(s){return s==null?s===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(s)}const Ou="[object RegExp]",yo="[object String]",vo="[object Number]",Eo="[object Boolean]",bo="[object Arguments]",_u="[object Symbol]",Tu="[object Date]",Ru="[object Map]",$u="[object Set]",ku="[object Array]",qu="[object ArrayBuffer]",xu="[object Object]",Uu="[object DataView]",Du="[object Uint8Array]",Lu="[object Uint8ClampedArray]",ju="[object Uint16Array]",Bu="[object Uint32Array]",Mu="[object Int8Array]",Hu="[object Int16Array]",Fu="[object Int32Array]",Vu="[object Float32Array]",zu="[object Float64Array]";function Wu(s,e){return Dt(s,void 0,s,new Map,e)}function Dt(s,e,t,i=new Map,n=void 0){const r=n==null?void 0:n(s,e,t,i);if(r!=null)return r;if(Di(s))return s;if(i.has(s))return i.get(s);if(Array.isArray(s)){const o=new Array(s.length);i.set(s,o);for(let a=0;a<s.length;a++)o[a]=Dt(s[a],a,t,i,n);return Object.hasOwn(s,"index")&&(o.index=s.index),Object.hasOwn(s,"input")&&(o.input=s.input),o}if(s instanceof Date)return new Date(s.getTime());if(s instanceof RegExp){const o=new RegExp(s.source,s.flags);return o.lastIndex=s.lastIndex,o}if(s instanceof Map){const o=new Map;i.set(s,o);for(const[a,c]of s)o.set(a,Dt(c,a,t,i,n));return o}if(s instanceof Set){const o=new Set;i.set(s,o);for(const a of s)o.add(Dt(a,void 0,t,i,n));return o}if(typeof We<"u"&&We.isBuffer(s))return s.subarray();if(Li(s)){const o=new(Object.getPrototypeOf(s)).constructor(s.length);i.set(s,o);for(let a=0;a<s.length;a++)o[a]=Dt(s[a],a,t,i,n);return o}if(s instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&s instanceof SharedArrayBuffer)return s.slice(0);if(s instanceof DataView){const o=new DataView(s.buffer.slice(0),s.byteOffset,s.byteLength);return i.set(s,o),at(o,s,t,i,n),o}if(typeof File<"u"&&s instanceof File){const o=new File([s],s.name,{type:s.type});return i.set(s,o),at(o,s,t,i,n),o}if(s instanceof Blob){const o=new Blob([s],{type:s.type});return i.set(s,o),at(o,s,t,i,n),o}if(s instanceof Error){const o=new s.constructor;return i.set(s,o),o.message=s.message,o.name=s.name,o.stack=s.stack,o.cause=s.cause,at(o,s,t,i,n),o}if(typeof s=="object"&&Ku(s)){const o=Object.create(Object.getPrototypeOf(s));return i.set(s,o),at(o,s,t,i,n),o}return s}function at(s,e,t=s,i,n){const r=[...Object.keys(e),...wo(e)];for(let o=0;o<r.length;o++){const a=r[o],c=Object.getOwnPropertyDescriptor(s,a);(c==null||c.writable)&&(s[a]=Dt(e[a],a,t,i,n))}}function Ku(s){switch(mo(s)){case bo:case ku:case qu:case Uu:case Eo:case Tu:case Vu:case zu:case Mu:case Hu:case Fu:case Ru:case vo:case xu:case Ou:case $u:case yo:case _u:case Du:case Lu:case ju:case Bu:return!0;default:return!1}}function Gu(s,e){return Wu(s,(t,i,n,r)=>{if(typeof s=="object")switch(Object.prototype.toString.call(s)){case vo:case yo:case Eo:{const o=new s.constructor(s==null?void 0:s.valueOf());return at(o,s),o}case bo:{const o={};return at(o,s),o.length=s.length,o[Symbol.iterator]=s[Symbol.iterator],o}default:return}})}function Gn(s){return Gu(s)}function Jn(s){return s!==null&&typeof s=="object"&&mo(s)==="[object Arguments]"}function Ju(s){return Li(s)}function Yu(s){var t;if(typeof s!="object"||s==null)return!1;if(Object.getPrototypeOf(s)===null)return!0;if(Object.prototype.toString.call(s)!=="[object Object]"){const i=s[Symbol.toStringTag];return i==null||!((t=Object.getOwnPropertyDescriptor(s,Symbol.toStringTag))!=null&&t.writable)?!1:s.toString()===`[object ${i}]`}let e=s;for(;Object.getPrototypeOf(e)!==null;)e=Object.getPrototypeOf(e);return Object.getPrototypeOf(s)===e}function Zu(s,...e){const t=e.slice(0,-1),i=e[e.length-1];let n=s;for(let r=0;r<t.length;r++){const o=t[r];n=Ci(n,o,i,new Map)}return n}function Ci(s,e,t,i){if(Di(s)&&(s=Object(s)),e==null||typeof e!="object")return s;if(i.has(e))return Su(i.get(e));if(i.set(e,s),Array.isArray(e)){e=e.slice();for(let r=0;r<e.length;r++)e[r]=e[r]??void 0}const n=[...Object.keys(e),...wo(e)];for(let r=0;r<n.length;r++){const o=n[r];let a=e[o],c=s[o];if(Jn(a)&&(a={...a}),Jn(c)&&(c={...c}),typeof We<"u"&&We.isBuffer(a)&&(a=Gn(a)),Array.isArray(a))if(typeof c=="object"&&c!=null){const h=[],u=Reflect.ownKeys(c);for(let d=0;d<u.length;d++){const f=u[d];h[f]=c[f]}c=h}else c=[];const l=t(c,a,o,s,e,i);l!=null?s[o]=l:Array.isArray(a)||Kn(c)&&Kn(a)?s[o]=Ci(c,a,t,i):c==null&&Yu(a)?s[o]=Ci({},a,t,i):c==null&&Ju(a)?s[o]=Gn(a):(c===void 0||a!==void 0)&&(s[o]=a)}return s}function Qu(s,...e){return Zu(s,...e,Pu)}var Xu=Object.defineProperty,ed=Object.defineProperties,td=Object.getOwnPropertyDescriptors,Yn=Object.getOwnPropertySymbols,sd=Object.prototype.hasOwnProperty,id=Object.prototype.propertyIsEnumerable,Zn=(s,e,t)=>e in s?Xu(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,As=(s,e)=>{for(var t in e||(e={}))sd.call(e,t)&&Zn(s,t,e[t]);if(Yn)for(var t of Yn(e))id.call(e,t)&&Zn(s,t,e[t]);return s},nd=(s,e)=>ed(s,td(e));function Ce(s,e,t){var i;const n=Lt(s);return((i=e.rpcMap)==null?void 0:i[n.reference])||`${go}?chainId=${n.namespace}:${n.reference}&projectId=${t}`}function pt(s){return s.includes(":")?s.split(":")[1]:s}function Io(s){return s.map(e=>`${e.split(":")[0]}:${e.split(":")[1]}`)}function rd(s,e){const t=Object.keys(e.namespaces).filter(n=>n.includes(s));if(!t.length)return[];const i=[];return t.forEach(n=>{const r=e.namespaces[n].accounts;i.push(...r)}),i}function Ns(s={},e={}){const t=Qn(s),i=Qn(e);return Qu(t,i)}function Qn(s){var e,t,i,n,r;const o={};if(!tt(s))return o;for(const[a,c]of Object.entries(s)){const l=Bs(a)?[a]:c.chains,h=c.methods||[],u=c.events||[],d=c.rpcMap||{},f=Ut(a);o[f]=nd(As(As({},o[f]),c),{chains:Ue(l,(e=o[f])==null?void 0:e.chains),methods:Ue(h,(t=o[f])==null?void 0:t.methods),events:Ue(u,(i=o[f])==null?void 0:i.events)}),(tt(d)||tt(((n=o[f])==null?void 0:n.rpcMap)||{}))&&(o[f].rpcMap=As(As({},d),(r=o[f])==null?void 0:r.rpcMap))}return o}function Xn(s){return s.includes(":")?s.split(":")[2]:s}function er(s){const e={};for(const[t,i]of Object.entries(s)){const n=i.methods||[],r=i.events||[],o=i.accounts||[],a=Bs(t)?[t]:i.chains?i.chains:Io(i.accounts);e[t]={chains:a,methods:n,events:r,accounts:o}}return e}function oi(s){return typeof s=="number"?s:s.includes("0x")?parseInt(s,16):(s=s.includes(":")?s.split(":")[1]:s,isNaN(Number(s))?s:Number(s))}const Co={},K=s=>Co[s],ai=(s,e)=>{Co[s]=e};var od=Object.defineProperty,ad=(s,e,t)=>e in s?od(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,bt=(s,e,t)=>ad(s,typeof e!="symbol"?e+"":e,t);class cd{constructor(e){bt(this,"name","polkadot"),bt(this,"client"),bt(this,"httpProviders"),bt(this,"events"),bt(this,"namespace"),bt(this,"chainId"),this.namespace=e.namespace,this.events=K("events"),this.client=K("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(Ne.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const n=pt(t);e[n]=this.createHttpProvider(n,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Ce(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Te(new Re(i,K("disableProviderPing")))}}var ld=Object.defineProperty,hd=Object.defineProperties,ud=Object.getOwnPropertyDescriptors,tr=Object.getOwnPropertySymbols,dd=Object.prototype.hasOwnProperty,pd=Object.prototype.propertyIsEnumerable,Ai=(s,e,t)=>e in s?ld(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,sr=(s,e)=>{for(var t in e||(e={}))dd.call(e,t)&&Ai(s,t,e[t]);if(tr)for(var t of tr(e))pd.call(e,t)&&Ai(s,t,e[t]);return s},ir=(s,e)=>hd(s,ud(e)),It=(s,e,t)=>Ai(s,typeof e!="symbol"?e+"":e,t);class fd{constructor(e){It(this,"name","eip155"),It(this,"client"),It(this,"chainId"),It(this,"namespace"),It(this,"httpProviders"),It(this,"events"),this.namespace=e.namespace,this.events=K("events"),this.client=K("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain())}async request(e){switch(e.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(e);case"eth_chainId":return parseInt(this.getDefaultChain());case"wallet_getCapabilities":return await this.getCapabilities(e);case"wallet_getCallsStatus":return await this.getCallStatus(e)}return this.namespace.methods.includes(e.request.method)?await this.client.request(e):this.getHttpProvider().request(e.request)}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(parseInt(e),t),this.chainId=parseInt(e),this.events.emit(Ne.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}createHttpProvider(e,t){const i=t||Ce(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Te(new Re(i,K("disableProviderPing")))}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const n=parseInt(pt(t));e[n]=this.createHttpProvider(n,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}getHttpProvider(){const e=this.chainId,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}async handleSwitchChain(e){var t,i;let n=e.request.params?(t=e.request.params[0])==null?void 0:t.chainId:"0x0";n=n.startsWith("0x")?n:`0x${n}`;const r=parseInt(n,16);if(this.isChainApproved(r))this.setDefaultChain(`${r}`);else if(this.namespace.methods.includes("wallet_switchEthereumChain"))await this.client.request({topic:e.topic,request:{method:e.request.method,params:[{chainId:n}]},chainId:(i=this.namespace.chains)==null?void 0:i[0]}),this.setDefaultChain(`${r}`);else throw new Error(`Failed to switch to chain 'eip155:${r}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(e){return this.namespace.chains.includes(`${this.name}:${e}`)}async getCapabilities(e){var t,i,n,r,o;const a=(i=(t=e.request)==null?void 0:t.params)==null?void 0:i[0],c=((r=(n=e.request)==null?void 0:n.params)==null?void 0:r[1])||[],l=`${a}${c.join(",")}`;if(!a)throw new Error("Missing address parameter in `wallet_getCapabilities` request");const h=this.client.session.get(e.topic),u=((o=h==null?void 0:h.sessionProperties)==null?void 0:o.capabilities)||{};if(u!=null&&u[l])return u==null?void 0:u[l];const d=await this.client.request(e);try{await this.client.session.update(e.topic,{sessionProperties:ir(sr({},h.sessionProperties||{}),{capabilities:ir(sr({},u||{}),{[l]:d})})})}catch(f){console.warn("Failed to update session with capabilities",f)}return d}async getCallStatus(e){var t,i;const n=this.client.session.get(e.topic),r=(t=n.sessionProperties)==null?void 0:t.bundler_name;if(r){const a=this.getBundlerUrl(e.chainId,r);try{return await this.getUserOperationReceipt(a,e)}catch(c){console.warn("Failed to fetch call status from bundler",c,a)}}const o=(i=n.sessionProperties)==null?void 0:i.bundler_url;if(o)try{return await this.getUserOperationReceipt(o,e)}catch(a){console.warn("Failed to fetch call status from custom bundler",a,o)}if(this.namespace.methods.includes(e.request.method))return await this.client.request(e);throw new Error("Fetching call status not approved by the wallet.")}async getUserOperationReceipt(e,t){var i;const n=new URL(e),r=await fetch(n,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(rs("eth_getUserOperationReceipt",[(i=t.request.params)==null?void 0:i[0]]))});if(!r.ok)throw new Error(`Failed to fetch user operation receipt - ${r.status}`);return await r.json()}getBundlerUrl(e,t){return`${Nu}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`}}var gd=Object.defineProperty,wd=(s,e,t)=>e in s?gd(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,Ct=(s,e,t)=>wd(s,typeof e!="symbol"?e+"":e,t);class md{constructor(e){Ct(this,"name","solana"),Ct(this,"client"),Ct(this,"httpProviders"),Ct(this,"events"),Ct(this,"namespace"),Ct(this,"chainId"),this.namespace=e.namespace,this.events=K("events"),this.client=K("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(Ne.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const n=pt(t);e[n]=this.createHttpProvider(n,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Ce(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Te(new Re(i,K("disableProviderPing")))}}var yd=Object.defineProperty,vd=(s,e,t)=>e in s?yd(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,At=(s,e,t)=>vd(s,typeof e!="symbol"?e+"":e,t);class Ed{constructor(e){At(this,"name","cosmos"),At(this,"client"),At(this,"httpProviders"),At(this,"events"),At(this,"namespace"),At(this,"chainId"),this.namespace=e.namespace,this.events=K("events"),this.client=K("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(Ne.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const n=pt(t);e[n]=this.createHttpProvider(n,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Ce(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Te(new Re(i,K("disableProviderPing")))}}var bd=Object.defineProperty,Id=(s,e,t)=>e in s?bd(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,Nt=(s,e,t)=>Id(s,typeof e!="symbol"?e+"":e,t);class Cd{constructor(e){Nt(this,"name","algorand"),Nt(this,"client"),Nt(this,"httpProviders"),Nt(this,"events"),Nt(this,"namespace"),Nt(this,"chainId"),this.namespace=e.namespace,this.events=K("events"),this.client=K("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(!this.httpProviders[e]){const i=t||Ce(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,i)}this.chainId=e,this.events.emit(Ne.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;e[t]=this.createHttpProvider(t,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Ce(e,this.namespace,this.client.core.projectId);return typeof i>"u"?void 0:new Te(new Re(i,K("disableProviderPing")))}}var Ad=Object.defineProperty,Nd=(s,e,t)=>e in s?Ad(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,Pt=(s,e,t)=>Nd(s,typeof e!="symbol"?e+"":e,t);class Pd{constructor(e){Pt(this,"name","cip34"),Pt(this,"client"),Pt(this,"httpProviders"),Pt(this,"events"),Pt(this,"namespace"),Pt(this,"chainId"),this.namespace=e.namespace,this.events=K("events"),this.client=K("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(Ne.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{const i=this.getCardanoRPCUrl(t),n=pt(t);e[n]=this.createHttpProvider(n,i)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}getCardanoRPCUrl(e){const t=this.namespace.rpcMap;if(t)return t[e]}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||this.getCardanoRPCUrl(e);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Te(new Re(i,K("disableProviderPing")))}}var Sd=Object.defineProperty,Od=(s,e,t)=>e in s?Sd(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,St=(s,e,t)=>Od(s,typeof e!="symbol"?e+"":e,t);class _d{constructor(e){St(this,"name","elrond"),St(this,"client"),St(this,"httpProviders"),St(this,"events"),St(this,"namespace"),St(this,"chainId"),this.namespace=e.namespace,this.events=K("events"),this.client=K("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(Ne.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const n=pt(t);e[n]=this.createHttpProvider(n,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Ce(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Te(new Re(i,K("disableProviderPing")))}}var Td=Object.defineProperty,Rd=(s,e,t)=>e in s?Td(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,Ot=(s,e,t)=>Rd(s,typeof e!="symbol"?e+"":e,t);class $d{constructor(e){Ot(this,"name","multiversx"),Ot(this,"client"),Ot(this,"httpProviders"),Ot(this,"events"),Ot(this,"namespace"),Ot(this,"chainId"),this.namespace=e.namespace,this.events=K("events"),this.client=K("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(Ne.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;const n=pt(t);e[n]=this.createHttpProvider(n,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Ce(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Te(new Re(i,K("disableProviderPing")))}}var kd=Object.defineProperty,qd=(s,e,t)=>e in s?kd(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,_t=(s,e,t)=>qd(s,typeof e!="symbol"?e+"":e,t);class xd{constructor(e){_t(this,"name","near"),_t(this,"client"),_t(this,"httpProviders"),_t(this,"events"),_t(this,"namespace"),_t(this,"chainId"),this.namespace=e.namespace,this.events=K("events"),this.client=K("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const i=t||Ce(`${this.name}:${e}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,i)}this.events.emit(Ne.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var i;e[t]=this.createHttpProvider(t,(i=this.namespace.rpcMap)==null?void 0:i[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Ce(e,this.namespace);return typeof i>"u"?void 0:new Te(new Re(i,K("disableProviderPing")))}}var Ud=Object.defineProperty,Dd=(s,e,t)=>e in s?Ud(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,Tt=(s,e,t)=>Dd(s,typeof e!="symbol"?e+"":e,t);class Ld{constructor(e){Tt(this,"name","tezos"),Tt(this,"client"),Tt(this,"httpProviders"),Tt(this,"events"),Tt(this,"namespace"),Tt(this,"chainId"),this.namespace=e.namespace,this.events=K("events"),this.client=K("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const i=t||Ce(`${this.name}:${e}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,i)}this.events.emit(Ne.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Ce(e,this.namespace);return typeof i>"u"?void 0:new Te(new Re(i))}}var jd=Object.defineProperty,Bd=(s,e,t)=>e in s?jd(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,Rt=(s,e,t)=>Bd(s,typeof e!="symbol"?e+"":e,t);class Md{constructor(e){Rt(this,"name",kt),Rt(this,"client"),Rt(this,"httpProviders"),Rt(this,"events"),Rt(this,"namespace"),Rt(this,"chainId"),this.namespace=e.namespace,this.events=K("events"),this.client=K("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(e.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(e.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(e.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(e.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider(e.chainId).request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(Ne.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){var e,t;const i={};return(t=(e=this.namespace)==null?void 0:e.accounts)==null||t.forEach(n=>{const r=Lt(n);i[`${r.namespace}:${r.reference}`]=this.createHttpProvider(n)}),i}getHttpProvider(e){const t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const i=this.createHttpProvider(e,t);i&&(this.httpProviders[e]=i)}createHttpProvider(e,t){const i=t||Ce(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Te(new Re(i,K("disableProviderPing")))}}var Hd=Object.defineProperty,Fd=Object.defineProperties,Vd=Object.getOwnPropertyDescriptors,nr=Object.getOwnPropertySymbols,zd=Object.prototype.hasOwnProperty,Wd=Object.prototype.propertyIsEnumerable,Ni=(s,e,t)=>e in s?Hd(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,Ps=(s,e)=>{for(var t in e||(e={}))zd.call(e,t)&&Ni(s,t,e[t]);if(nr)for(var t of nr(e))Wd.call(e,t)&&Ni(s,t,e[t]);return s},ci=(s,e)=>Fd(s,Vd(e)),Ae=(s,e,t)=>Ni(s,typeof e!="symbol"?e+"":e,t);class ji{constructor(e){Ae(this,"client"),Ae(this,"namespaces"),Ae(this,"optionalNamespaces"),Ae(this,"sessionProperties"),Ae(this,"scopedProperties"),Ae(this,"events",new dr),Ae(this,"rpcProviders",{}),Ae(this,"session"),Ae(this,"providerOpts"),Ae(this,"logger"),Ae(this,"uri"),Ae(this,"disableProviderPing",!1),this.providerOpts=e,this.logger=typeof(e==null?void 0:e.logger)<"u"&&typeof(e==null?void 0:e.logger)!="string"?e.logger:hr(ur({level:(e==null?void 0:e.logger)||Wn})),this.disableProviderPing=(e==null?void 0:e.disableProviderPing)||!1}static async init(e){const t=new ji(e);return await t.initialize(),t}async request(e,t,i){const[n,r]=this.validateChain(t);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(n).request({request:Ps({},e),chainId:`${n}:${r}`,topic:this.session.topic,expiry:i})}sendAsync(e,t,i,n){const r=new Date().getTime();this.request(e,i,n).then(o=>t(null,pr(r,o))).catch(o=>t(o,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties}),await this.requestAccounts()}async disconnect(){var e;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(e=this.session)==null?void 0:e.topic,reason:X("USER_DISCONNECTED")}),await this.cleanup()}async connect(e){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(e),await this.cleanupPendingPairings(),!e.skipPairing)return await this.pair(e.pairingTopic)}async authenticate(e,t){if(!this.client)throw new Error("Sign Client not initialized");this.setNamespaces(e),await this.cleanupPendingPairings();const{uri:i,response:n}=await this.client.authenticate(e,t);i&&(this.uri=i,this.events.emit("display_uri",i));const r=await n();if(this.session=r.session,this.session){const o=er(this.session.namespaces);this.namespaces=Ns(this.namespaces,o),await this.persist("namespaces",this.namespaces),this.onConnect()}return r}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}removeListener(e,t){this.events.removeListener(e,t)}off(e,t){this.events.off(e,t)}get isWalletConnect(){return!0}async pair(e){const{uri:t,approval:i}=await this.client.connect({pairingTopic:e,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties});t&&(this.uri=t,this.events.emit("display_uri",t));const n=await i();this.session=n;const r=er(n.namespaces);return this.namespaces=Ns(this.namespaces,r),await this.persist("namespaces",this.namespaces),await this.persist("optionalNamespaces",this.optionalNamespaces),this.onConnect(),this.session}setDefaultChain(e,t){try{if(!this.session)return;const[i,n]=this.validateChain(e),r=this.getProvider(i);r.name===kt?r.setDefaultChain(`${i}:${n}`,t):r.setDefaultChain(n,t)}catch(i){if(!/Please call connect/.test(i.message))throw i}}async cleanupPendingPairings(e={}){this.logger.info("Cleaning up inactive pairings...");const t=this.client.pairing.getAll();if(et(t)){for(const i of t)e.deletePairings?this.client.core.expirer.set(i.topic,0):await this.client.core.relayer.subscriber.unsubscribe(i.topic);this.logger.info(`Inactive pairings cleared: ${t.length}`)}}abortPairingAttempt(){this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")}async checkStorage(){this.namespaces=await this.getFromStore("namespaces")||{},this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.session&&this.createProviders()}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){var e,t;if(this.client=this.providerOpts.client||await bu.init({core:this.providerOpts.core,logger:this.providerOpts.logger||Wn,relayUrl:this.providerOpts.relayUrl||Iu,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.providerOpts.session)try{this.session=this.client.session.get(this.providerOpts.session.topic)}catch(i){throw this.logger.error("Failed to get session",i),new Error(`The provided session: ${(t=(e=this.providerOpts)==null?void 0:e.session)==null?void 0:t.topic} doesn't exist in the Sign client`)}else{const i=this.client.session.getAll();this.session=i[0]}this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const e=[...new Set(Object.keys(this.session.namespaces).map(t=>Ut(t)))];ai("client",this.client),ai("events",this.events),ai("disableProviderPing",this.disableProviderPing),e.forEach(t=>{if(!this.session)return;const i=rd(t,this.session),n=Io(i),r=Ns(this.namespaces,this.optionalNamespaces),o=ci(Ps({},r[t]),{accounts:i,chains:n});switch(t){case"eip155":this.rpcProviders[t]=new fd({namespace:o});break;case"algorand":this.rpcProviders[t]=new Cd({namespace:o});break;case"solana":this.rpcProviders[t]=new md({namespace:o});break;case"cosmos":this.rpcProviders[t]=new Ed({namespace:o});break;case"polkadot":this.rpcProviders[t]=new cd({namespace:o});break;case"cip34":this.rpcProviders[t]=new Pd({namespace:o});break;case"elrond":this.rpcProviders[t]=new _d({namespace:o});break;case"multiversx":this.rpcProviders[t]=new $d({namespace:o});break;case"near":this.rpcProviders[t]=new xd({namespace:o});break;case"tezos":this.rpcProviders[t]=new Ld({namespace:o});break;default:this.rpcProviders[kt]?this.rpcProviders[kt].updateNamespace(o):this.rpcProviders[kt]=new Md({namespace:o})}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",e=>{var t;const{topic:i}=e;i===((t=this.session)==null?void 0:t.topic)&&this.events.emit("session_ping",e)}),this.client.on("session_event",e=>{var t;const{params:i,topic:n}=e;if(n!==((t=this.session)==null?void 0:t.topic))return;const{event:r}=i;if(r.name==="accountsChanged"){const o=r.data;o&&et(o)&&this.events.emit("accountsChanged",o.map(Xn))}else if(r.name==="chainChanged"){const o=i.chainId,a=i.event.data,c=Ut(o),l=oi(o)!==oi(a)?`${c}:${oi(a)}`:o;this.onChainChanged(l)}else this.events.emit(r.name,r.data);this.events.emit("session_event",e)}),this.client.on("session_update",({topic:e,params:t})=>{var i,n;if(e!==((i=this.session)==null?void 0:i.topic))return;const{namespaces:r}=t,o=(n=this.client)==null?void 0:n.session.get(e);this.session=ci(Ps({},o),{namespaces:r}),this.onSessionUpdate(),this.events.emit("session_update",{topic:e,params:t})}),this.client.on("session_delete",async e=>{var t;e.topic===((t=this.session)==null?void 0:t.topic)&&(await this.cleanup(),this.events.emit("session_delete",e),this.events.emit("disconnect",ci(Ps({},X("USER_DISCONNECTED")),{data:e.topic})))}),this.on(Ne.DEFAULT_CHAIN_CHANGED,e=>{this.onChainChanged(e,!0)})}getProvider(e){return this.rpcProviders[e]||this.rpcProviders[kt]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(e=>{var t;this.getProvider(e).updateNamespace((t=this.session)==null?void 0:t.namespaces[e])})}setNamespaces(e){const{namespaces:t={},optionalNamespaces:i={},sessionProperties:n,scopedProperties:r}=e;this.optionalNamespaces=Ns(t,i),this.sessionProperties=n,this.scopedProperties=r}validateChain(e){const[t,i]=(e==null?void 0:e.split(":"))||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return[t,i];if(t&&!Object.keys(this.namespaces||{}).map(o=>Ut(o)).includes(t))throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);if(t&&i)return[t,i];const n=Ut(Object.keys(this.namespaces)[0]),r=this.rpcProviders[n].getDefaultChain();return[n,r]}async requestAccounts(){const[e]=this.validateChain();return await this.getProvider(e).requestAccounts()}async onChainChanged(e,t=!1){if(!this.namespaces)return;const[i,n]=this.validateChain(e);if(!n)return;this.updateNamespaceChain(i,n),this.events.emit("chainChanged",n);const r=this.getProvider(i).getDefaultChain();t||this.getProvider(i).setDefaultChain(n),this.emitAccountsChangedOnChainChange({namespace:i,previousChainId:r,newChainId:e}),await this.persist("namespaces",this.namespaces)}emitAccountsChangedOnChainChange({namespace:e,previousChainId:t,newChainId:i}){var n,r;try{if(t===i)return;const o=(r=(n=this.session)==null?void 0:n.namespaces[e])==null?void 0:r.accounts;if(!o)return;const a=o.filter(c=>c.includes(`${i}:`)).map(Xn);if(!et(a))return;this.events.emit("accountsChanged",a)}catch(o){this.logger.warn("Failed to emit accountsChanged on chain change",o)}}updateNamespaceChain(e,t){if(!this.namespaces)return;const i=this.namespaces[e]?e:`${e}:${t}`,n={chains:[],methods:[],events:[],defaultChain:t};this.namespaces[i]?this.namespaces[i]&&(this.namespaces[i].defaultChain=t):this.namespaces[i]=n}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,await this.deleteFromStore("namespaces"),await this.deleteFromStore("optionalNamespaces"),await this.deleteFromStore("sessionProperties"),this.session=void 0,await this.cleanupPendingPairings({deletePairings:!0}),await this.cleanupStorage()}async persist(e,t){var i;const n=((i=this.session)==null?void 0:i.topic)||"";await this.client.core.storage.setItem(`${Cs}/${e}${n}`,t)}async getFromStore(e){var t;const i=((t=this.session)==null?void 0:t.topic)||"";return await this.client.core.storage.getItem(`${Cs}/${e}${i}`)}async deleteFromStore(e){var t;const i=((t=this.session)==null?void 0:t.topic)||"";await this.client.core.storage.removeItem(`${Cs}/${e}${i}`)}async cleanupStorage(){var e;try{if(((e=this.client)==null?void 0:e.session.length)>0)return;const t=await this.client.core.storage.getKeys();for(const i of t)i.startsWith(Cs)&&await this.client.core.storage.removeItem(i)}catch(t){this.logger.warn("Failed to cleanup storage",t)}}}const os={ERROR_CODE_UNRECOGNIZED_CHAIN_ID:4902,ERROR_CODE_DEFAULT:5e3,ERROR_INVALID_CHAIN_ID:32603,DEFAULT_ALLOWED_ANCESTORS:["http://localhost:*","https://*.pages.dev","https://*.vercel.app","https://*.ngrok-free.app","https://secure-mobile.walletconnect.com","https://secure-mobile.walletconnect.org"]};function ps(s){return{formatters:void 0,fees:void 0,serializers:void 0,...s}}const rr=ps({id:"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",name:"Solana",network:"solana-mainnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!1,chainNamespace:"solana",caipNetworkId:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",deprecatedCaipNetworkId:"solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"}),or=ps({id:"EtWTRABZaYq6iMfeYKouRu166VU2xqa1",name:"Solana Devnet",network:"solana-devnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!0,chainNamespace:"solana",caipNetworkId:"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",deprecatedCaipNetworkId:"solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"});ps({id:"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",name:"Solana Testnet",network:"solana-testnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!0,chainNamespace:"solana",caipNetworkId:"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"});ps({id:"000000000019d6689c085ae165831e93",caipNetworkId:"bip122:000000000019d6689c085ae165831e93",chainNamespace:"bip122",name:"Bitcoin",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}}});ps({id:"000000000933ea01ad0ee984209779ba",caipNetworkId:"bip122:000000000933ea01ad0ee984209779ba",chainNamespace:"bip122",name:"Bitcoin Testnet",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},testnet:!0});const Kd={solana:["solana_signMessage","solana_signTransaction","solana_requestAccounts","solana_getAccounts","solana_signAllTransactions","solana_signAndSendTransaction"],eip155:["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_getCallsStatus","wallet_showCallsStatus","wallet_sendCalls","wallet_getCapabilities","wallet_grantPermissions","wallet_revokePermissions","wallet_getAssets"],bip122:["sendTransfer","signMessage","signPsbt","getAccountAddresses"]},Rs={getMethodsByChainNamespace(s){return Kd[s]||[]},createDefaultNamespace(s){return{methods:this.getMethodsByChainNamespace(s),events:["accountsChanged","chainChanged"],chains:[],rpcMap:{}}},applyNamespaceOverrides(s,e){if(!e)return{...s};const t={...s},i=new Set;if(e.methods&&Object.keys(e.methods).forEach(n=>i.add(n)),e.chains&&Object.keys(e.chains).forEach(n=>i.add(n)),e.events&&Object.keys(e.events).forEach(n=>i.add(n)),e.rpcMap&&Object.keys(e.rpcMap).forEach(n=>{const[r]=n.split(":");r&&i.add(r)}),i.forEach(n=>{t[n]||(t[n]=this.createDefaultNamespace(n))}),e.methods&&Object.entries(e.methods).forEach(([n,r])=>{t[n]&&(t[n].methods=r)}),e.chains&&Object.entries(e.chains).forEach(([n,r])=>{t[n]&&(t[n].chains=r)}),e.events&&Object.entries(e.events).forEach(([n,r])=>{t[n]&&(t[n].events=r)}),e.rpcMap){const n=new Set;Object.entries(e.rpcMap).forEach(([r,o])=>{const[a,c]=r.split(":");!a||!c||!t[a]||(t[a].rpcMap||(t[a].rpcMap={}),n.has(a)||(t[a].rpcMap={},n.add(a)),t[a].rpcMap[c]=o)})}return t},createNamespaces(s,e){const t=s.reduce((i,n)=>{const{id:r,chainNamespace:o,rpcUrls:a}=n,c=a.default.http[0];i[o]||(i[o]=this.createDefaultNamespace(o));const l=`${o}:${r}`,h=i[o];switch(h.chains.push(l),l){case rr.caipNetworkId:h.chains.push(rr.deprecatedCaipNetworkId);break;case or.caipNetworkId:h.chains.push(or.deprecatedCaipNetworkId);break}return h!=null&&h.rpcMap&&c&&(h.rpcMap[r]=c),i},{});return this.applyNamespaceOverrides(t,e)},resolveReownName:async s=>{var i;const e=await fr.resolveName(s);return((i=(Object.values(e==null?void 0:e.addresses)||[])[0])==null?void 0:i.address)||!1},getChainsFromNamespaces(s={}){return Object.values(s).flatMap(e=>{const t=e.chains||[],i=e.accounts.map(n=>{const[r,o]=n.split(":");return`${r}:${o}`});return Array.from(new Set([...t,...i]))})},isSessionEventData(s){return typeof s=="object"&&s!==null&&"id"in s&&"topic"in s&&"params"in s&&typeof s.params=="object"&&s.params!==null&&"chainId"in s.params&&"event"in s.params&&typeof s.params.event=="object"&&s.params.event!==null},isOriginAllowed(s,e,t){for(const i of[...e,...t])if(i.includes("*")){const r=`^${i.replace(/[.*+?^${}()|[\]\\]/gu,"\\$&").replace(/\\\*/gu,".*")}$`;if(new RegExp(r,"u").test(s))return!0}else try{if(new URL(i).origin===s)return!0}catch{if(i===s)return!0}return!1}};class Ao{constructor({provider:e,namespace:t}){this.id=te.CONNECTOR_ID.WALLET_CONNECT,this.name=hi.ConnectorNamesMap[te.CONNECTOR_ID.WALLET_CONNECT],this.type="WALLET_CONNECT",this.imageId=hi.ConnectorImageIds[te.CONNECTOR_ID.WALLET_CONNECT],this.getCaipNetworks=S.getCaipNetworks.bind(S),this.caipNetworks=this.getCaipNetworks(),this.provider=e,this.chain=t}get chains(){return this.getCaipNetworks()}async connectWalletConnect(){if(!await this.authenticate()){const t=this.getCaipNetworks(),i=U.state.universalProviderConfigOverride,n=Rs.createNamespaces(t,i);await this.provider.connect({optionalNamespaces:n})}return{clientId:await this.provider.client.core.crypto.getClientId(),session:this.provider.session}}async disconnect(){await this.provider.disconnect()}async authenticate(){const e=this.chains.map(t=>t.caipNetworkId);return gr.universalProviderAuthenticate({universalProvider:this.provider,chains:e,methods:Gd})}}const Gd=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_getCallsStatus","wallet_sendCalls","wallet_getCapabilities","wallet_grantPermissions","wallet_revokePermissions","wallet_getAssets"];class Jd{constructor(e){this.availableConnectors=[],this.eventListeners=new Map,this.getCaipNetworks=t=>S.getCaipNetworks(t),e&&this.construct(e)}construct(e){this.projectId=e.projectId,this.namespace=e.namespace,this.adapterType=e.adapterType}get connectors(){return this.availableConnectors}get networks(){return this.getCaipNetworks(this.namespace)}setAuthProvider(e){this.addConnector({id:te.CONNECTOR_ID.AUTH,type:"AUTH",name:te.CONNECTOR_NAMES.AUTH,provider:e,imageId:hi.ConnectorImageIds[te.CONNECTOR_ID.AUTH],chain:this.namespace,chains:[]})}addConnector(...e){const t=new Set;this.availableConnectors=[...e,...this.availableConnectors].filter(i=>t.has(i.id)?!1:(t.add(i.id),!0)),this.emit("connectors",this.availableConnectors)}setStatus(e,t){z.setStatus(e,t)}on(e,t){var i;this.eventListeners.has(e)||this.eventListeners.set(e,new Set),(i=this.eventListeners.get(e))==null||i.add(t)}off(e,t){const i=this.eventListeners.get(e);i&&i.delete(t)}removeAllEventListeners(){this.eventListeners.forEach(e=>{e.clear()})}emit(e,t){const i=this.eventListeners.get(e);i&&i.forEach(n=>n(t))}async connectWalletConnect(e){return{clientId:(await this.getWalletConnectConnector().connectWalletConnect()).clientId}}async switchNetwork(e){var r;const{caipNetwork:t,providerType:i}=e;if(!e.provider)return;const n="provider"in e.provider?e.provider.provider:e.provider;if(i==="WALLET_CONNECT"){n.setDefaultChain(t.caipNetworkId);return}if(n&&i==="AUTH"){const o=n,a=(r=z.state.preferredAccountTypes)==null?void 0:r[t.chainNamespace];await o.switchNetwork(t.caipNetworkId);const c=await o.getUser({chainId:t.caipNetworkId,preferredAccountType:a});this.emit("switchNetwork",c)}}getWalletConnectConnector(){const e=this.connectors.find(t=>t instanceof Ao);if(!e)throw new Error("WalletConnectConnector not found");return e}}class Yd extends Jd{setUniversalProvider(e){this.addConnector(new Ao({provider:e,caipNetworks:this.getCaipNetworks(),namespace:this.namespace}))}async connect(e){return Promise.resolve({id:"WALLET_CONNECT",type:"WALLET_CONNECT",chainId:Number(e.chainId),provider:this.provider,address:""})}async disconnect(){try{await this.getWalletConnectConnector().disconnect()}catch(e){console.warn("UniversalAdapter:disconnect - error",e)}}async getAccounts({namespace:e}){var n,r,o,a;const t=this.provider,i=((a=(o=(r=(n=t==null?void 0:t.session)==null?void 0:n.namespaces)==null?void 0:r[e])==null?void 0:o.accounts)==null?void 0:a.map(c=>{const[,,l]=c.split(":");return l}).filter((c,l,h)=>h.indexOf(c)===l))||[];return Promise.resolve({accounts:i.map(c=>xe.createAccount(e,c,e==="bip122"?"payment":"eoa"))})}async syncConnectors(){return Promise.resolve()}async getBalance(e){var r,o,a,c,l;if(!(e.caipNetwork&&ye.BALANCE_SUPPORTED_CHAINS.includes((r=e.caipNetwork)==null?void 0:r.chainNamespace))||(o=e.caipNetwork)!=null&&o.testnet)return{balance:"0.00",symbol:((a=e.caipNetwork)==null?void 0:a.nativeCurrency.symbol)||""};if(z.state.balanceLoading&&e.chainId===((c=S.state.activeCaipNetwork)==null?void 0:c.id))return{balance:z.state.balance||"0.00",symbol:z.state.balanceSymbol||""};const n=(await z.fetchTokenBalance()).find(h=>{var u,d;return h.chainId===`${(u=e.caipNetwork)==null?void 0:u.chainNamespace}:${e.chainId}`&&h.symbol===((d=e.caipNetwork)==null?void 0:d.nativeCurrency.symbol)});return{balance:(n==null?void 0:n.quantity.numeric)||"0.00",symbol:(n==null?void 0:n.symbol)||((l=e.caipNetwork)==null?void 0:l.nativeCurrency.symbol)||""}}async signMessage(e){var o,a,c;const{provider:t,message:i,address:n}=e;if(!t)throw new Error("UniversalAdapter:signMessage - provider is undefined");let r="";return((o=S.state.activeCaipNetwork)==null?void 0:o.chainNamespace)===te.CHAIN.SOLANA?r=(await t.request({method:"solana_signMessage",params:{message:lr.encode(new TextEncoder().encode(i)),pubkey:n}},(a=S.state.activeCaipNetwork)==null?void 0:a.caipNetworkId)).signature:r=await t.request({method:"personal_sign",params:[i,n]},(c=S.state.activeCaipNetwork)==null?void 0:c.caipNetworkId),{signature:r}}async estimateGas(){return Promise.resolve({gas:BigInt(0)})}async sendTransaction(){return Promise.resolve({hash:""})}walletGetAssets(e){return Promise.resolve({})}async writeContract(){return Promise.resolve({hash:""})}parseUnits(){return 0n}formatUnits(){return"0"}async getCapabilities(){return Promise.resolve({})}async grantPermissions(){return Promise.resolve({})}async revokePermissions(){return Promise.resolve("0x")}async syncConnection(){return Promise.resolve({id:"WALLET_CONNECT",type:"WALLET_CONNECT",chainId:1,provider:this.provider,address:""})}async switchNetwork(e){var n,r,o,a,c,l;const{caipNetwork:t}=e,i=this.getWalletConnectConnector();if(t.chainNamespace===te.CHAIN.EVM)try{await((n=i.provider)==null?void 0:n.request({method:"wallet_switchEthereumChain",params:[{chainId:Mi(t.id)}]}))}catch(h){if(h.code===os.ERROR_CODE_UNRECOGNIZED_CHAIN_ID||h.code===os.ERROR_INVALID_CHAIN_ID||h.code===os.ERROR_CODE_DEFAULT||((o=(r=h==null?void 0:h.data)==null?void 0:r.originalError)==null?void 0:o.code)===os.ERROR_CODE_UNRECOGNIZED_CHAIN_ID)try{await((l=i.provider)==null?void 0:l.request({method:"wallet_addEthereumChain",params:[{chainId:Mi(t.id),rpcUrls:[(a=t==null?void 0:t.rpcUrls.chainDefault)==null?void 0:a.http],chainName:t.name,nativeCurrency:t.nativeCurrency,blockExplorerUrls:[(c=t.blockExplorers)==null?void 0:c.default.url]}]}))}catch{throw new Error("Chain is not supported")}}i.provider.setDefaultChain(t.caipNetworkId)}getWalletConnectProvider(){const e=this.connectors.find(i=>i.type==="WALLET_CONNECT");return e==null?void 0:e.provider}}const Zd=["email","socials","swaps","onramp","activity","reownBranding"],Ss={email:{apiFeatureName:"social_login",localFeatureName:"email",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:s=>{if(!(s!=null&&s.config))return!1;const e=s.config;return!!s.isEnabled&&e.includes("email")},processFallback:s=>s===void 0?ye.DEFAULT_REMOTE_FEATURES.email:!!s},socials:{apiFeatureName:"social_login",localFeatureName:"socials",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:s=>{if(!(s!=null&&s.config))return!1;const e=s.config;return s.isEnabled&&e.length>0?e.filter(t=>t!=="email"):!1},processFallback:s=>s===void 0?ye.DEFAULT_REMOTE_FEATURES.socials:typeof s=="boolean"?s?ye.DEFAULT_REMOTE_FEATURES.socials:!1:s},swaps:{apiFeatureName:"swap",localFeatureName:"swaps",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:s=>{if(!(s!=null&&s.config))return!1;const e=s.config;return s.isEnabled&&e.length>0?e:!1},processFallback:s=>s===void 0?ye.DEFAULT_REMOTE_FEATURES.swaps:typeof s=="boolean"?s?ye.DEFAULT_REMOTE_FEATURES.swaps:!1:s},onramp:{apiFeatureName:"onramp",localFeatureName:"onramp",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:s=>{if(!(s!=null&&s.config))return!1;const e=s.config;return s.isEnabled&&e.length>0?e:!1},processFallback:s=>s===void 0?ye.DEFAULT_REMOTE_FEATURES.onramp:typeof s=="boolean"?s?ye.DEFAULT_REMOTE_FEATURES.onramp:!1:s},activity:{apiFeatureName:"activity",localFeatureName:"history",returnType:!1,isLegacy:!0,isAvailableOnBasic:!1,processApi:s=>!!s.isEnabled,processFallback:s=>s===void 0?ye.DEFAULT_REMOTE_FEATURES.activity:!!s},reownBranding:{apiFeatureName:"reown_branding",localFeatureName:"reownBranding",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:s=>!!s.isEnabled,processFallback:s=>s===void 0?ye.DEFAULT_REMOTE_FEATURES.reownBranding:!!s}},Qd={localSettingsOverridden:new Set,getApiConfig(s,e){return e==null?void 0:e.find(t=>t.id===s)},addWarning(s,e){if(s!==void 0){const t=Ss[e],i=t.isLegacy?`"features.${t.localFeatureName}" (now "${e}")`:`"features.${e}"`;this.localSettingsOverridden.add(i)}},processFeature(s,e,t,i,n){const r=Ss[s],o=e[r.localFeatureName];if(n&&!r.isAvailableOnBasic)return!1;if(i){const a=this.getApiConfig(r.apiFeatureName,t);return(a==null?void 0:a.config)===null?this.processFallbackFeature(s,o):a!=null&&a.config?(o!==void 0&&this.addWarning(o,s),this.processApiFeature(s,a)):!1}return this.processFallbackFeature(s,o)},processApiFeature(s,e){return Ss[s].processApi(e)},processFallbackFeature(s,e){return Ss[s].processFallback(e)},async fetchRemoteFeatures(s){const e=s.basic??!1,t=s.features||{};this.localSettingsOverridden.clear();let i=null,n=!1;try{i=await wr.fetchProjectConfig(),n=i!=null}catch(o){console.warn("[Reown Config] Failed to fetch remote project configuration. Using local/default values.",o)}const r=n&&!e?ye.DEFAULT_REMOTE_FEATURES:ye.DEFAULT_REMOTE_FEATURES_DISABLED;try{for(const o of Zd){const a=this.processFeature(o,t,i,n,e);Object.assign(r,{[o]:a})}}catch(o){return console.warn("[Reown Config] Failed to process the configuration from Cloud. Using default values.",o),ye.DEFAULT_REMOTE_FEATURES}if(n&&this.localSettingsOverridden.size>0){const o=`Your local configuration for ${Array.from(this.localSettingsOverridden).join(", ")} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;$t.open({shortMessage:"Local configuration ignored",longMessage:`[Reown Config Notice] ${o}`},"warning")}return r}};class Xd{constructor(e){this.chainNamespaces=[],this.remoteFeatures={},this.reportedAlertErrors={},this.getCaipNetwork=(t,i)=>{var n,r,o,a;if(t){const c=(r=(n=S.getNetworkData(t))==null?void 0:n.requestedCaipNetworks)==null?void 0:r.find(u=>u.id===i);if(c)return c;const l=(o=S.getNetworkData(t))==null?void 0:o.caipNetwork;return l||((a=S.getRequestedCaipNetworks(t).filter(u=>u.chainNamespace===t))==null?void 0:a[0])}return S.state.activeCaipNetwork||this.defaultCaipNetwork},this.getCaipNetworkId=()=>{const t=this.getCaipNetwork();if(t)return t.id},this.getCaipNetworks=t=>S.getCaipNetworks(t),this.getActiveChainNamespace=()=>S.state.activeChain,this.setRequestedCaipNetworks=(t,i)=>{S.setRequestedCaipNetworks(t,i)},this.getApprovedCaipNetworkIds=()=>S.getAllApprovedCaipNetworkIds(),this.getCaipAddress=t=>S.state.activeChain===t||!t?S.state.activeCaipAddress:S.getAccountProp("caipAddress",t),this.setClientId=t=>{Vi.setClientId(t)},this.getProvider=t=>Q.getProvider(t),this.getProviderType=t=>Q.getProviderId(t),this.getPreferredAccountType=t=>{var i;return(i=z.state.preferredAccountTypes)==null?void 0:i[t]},this.setCaipAddress=(t,i)=>{z.setCaipAddress(t,i),t&&U.state.enableEmbedded&&this.close()},this.setBalance=(t,i,n)=>{z.setBalance(t,i,n)},this.setProfileName=(t,i)=>{z.setProfileName(t,i)},this.setProfileImage=(t,i)=>{z.setProfileImage(t,i)},this.setUser=(t,i)=>{z.setUser(t,i)},this.resetAccount=t=>{z.resetAccount(t)},this.setCaipNetwork=t=>{S.setActiveCaipNetwork(t)},this.setCaipNetworkOfNamespace=(t,i)=>{S.setChainNetworkData(i,{caipNetwork:t})},this.setAllAccounts=(t,i)=>{z.setAllAccounts(t,i),U.setHasMultipleAddresses((t==null?void 0:t.length)>1)},this.setStatus=(t,i)=>{z.setStatus(t,i),ee.isConnected()?ge.setConnectionStatus("connected"):ge.setConnectionStatus("disconnected")},this.getAddressByChainNamespace=t=>S.getAccountProp("address",t),this.setConnectors=t=>{const i=[...ee.state.allConnectors,...t];ee.setConnectors(i)},this.setConnections=(t,i)=>{Oe.setConnections(t,i)},this.fetchIdentity=t=>Vi.fetchIdentity(t),this.getReownName=t=>fr.getNamesForAddress(t),this.getConnectors=()=>ee.getConnectors(),this.getConnectorImage=t=>Bo.getConnectorImage(t),this.setConnectedWalletInfo=(t,i)=>{const n=Q.getProviderId(i),r=t?{...t,type:n}:void 0;z.setConnectedWalletInfo(r,i)},this.getIsConnectedState=()=>!!S.state.activeCaipAddress,this.addAddressLabel=(t,i,n)=>{z.addAddressLabel(t,i,n)},this.removeAddressLabel=(t,i)=>{z.removeAddressLabel(t,i)},this.getAddress=t=>S.state.activeChain===t||!t?z.state.address:S.getAccountProp("address",t),this.setApprovedCaipNetworksData=t=>S.setApprovedCaipNetworksData(t),this.resetNetwork=t=>{S.resetNetwork(t)},this.addConnector=t=>{ee.addConnector(t)},this.resetWcConnection=()=>{Oe.resetWcConnection()},this.setAddressExplorerUrl=(t,i)=>{z.setAddressExplorerUrl(t,i)},this.setSmartAccountDeployed=(t,i)=>{z.setSmartAccountDeployed(t,i)},this.setSmartAccountEnabledNetworks=(t,i)=>{S.setSmartAccountEnabledNetworks(t,i)},this.setPreferredAccountType=(t,i)=>{z.setPreferredAccountType(t,i)},this.setEIP6963Enabled=t=>{U.setEIP6963Enabled(t)},this.handleUnsafeRPCRequest=()=>{if(this.isOpen()){if(this.isTransactionStackEmpty())return;this.redirect("ApproveTransaction")}else this.open({view:"ApproveTransaction"})},this.options=e,this.version=e.sdkVersion,this.caipNetworks=this.extendCaipNetworks(e),this.chainNamespaces=this.getChainNamespacesSet(e.adapters,this.caipNetworks),this.defaultCaipNetwork=this.extendDefaultCaipNetwork(e),this.chainAdapters=this.createAdapters(e.adapters),this.readyPromise=this.initialize(e)}getChainNamespacesSet(e,t){const i=e==null?void 0:e.map(r=>r.namespace).filter(r=>!!r);if(i!=null&&i.length)return[...new Set(i)];const n=t==null?void 0:t.map(r=>r.chainNamespace);return[...new Set(n)]}async initialize(e){var t,i,n;this.initializeProjectSettings(e),this.initControllers(e),await this.initChainAdapters(),this.sendInitializeEvent(e),await this.syncExistingConnection(),this.remoteFeatures=await Qd.fetchRemoteFeatures(e),U.setRemoteFeatures(this.remoteFeatures),this.remoteFeatures.onramp&&Mo.setOnrampProviders(this.remoteFeatures.onramp),((t=U.state.remoteFeatures)!=null&&t.email||Array.isArray((i=U.state.remoteFeatures)==null?void 0:i.socials)&&((n=U.state.remoteFeatures)==null?void 0:n.socials.length)>0)&&await this.checkAllowedOrigins()}async checkAllowedOrigins(){const e=await wr.fetchAllowedOrigins();if(e&&xe.isClient()){const t=window.location.origin;Rs.isOriginAllowed(t,e,os.DEFAULT_ALLOWED_ANCESTORS)||$t.open(ft.ALERT_ERRORS.INVALID_APP_CONFIGURATION,"error")}else $t.open(ft.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED,"error")}sendInitializeEvent(e){var i;const{...t}=e;delete t.adapters,delete t.universalProvider,Zt.sendEvent({type:"track",event:"INITIALIZE",properties:{...t,networks:e.networks.map(n=>n.id),siweConfig:{options:((i=e.siweConfig)==null?void 0:i.options)||{}}}})}initControllers(e){this.initializeOptionsController(e),this.initializeChainController(e),this.initializeThemeController(e),this.initializeConnectionController(e),this.initializeConnectorController()}initializeThemeController(e){e.themeMode&&Be.setThemeMode(e.themeMode),e.themeVariables&&Be.setThemeVariables(e.themeVariables)}initializeChainController(e){if(!this.connectionControllerClient||!this.networkControllerClient)throw new Error("ConnectionControllerClient and NetworkControllerClient must be set");S.initialize(e.adapters??[],this.caipNetworks,{connectionControllerClient:this.connectionControllerClient,networkControllerClient:this.networkControllerClient});const t=this.getDefaultNetwork();t&&S.setActiveCaipNetwork(t)}initializeConnectionController(e){Oe.setWcBasic(e.basic??!1)}initializeConnectorController(){ee.initialize(this.chainNamespaces)}initializeProjectSettings(e){U.setProjectId(e.projectId),U.setSdkVersion(e.sdkVersion)}initializeOptionsController(e){var o;U.setDebug(e.debug!==!1),U.setEnableWalletConnect(e.enableWalletConnect!==!1),U.setEnableWalletGuide(e.enableWalletGuide!==!1),U.setEnableWallets(e.enableWallets!==!1),U.setEIP6963Enabled(e.enableEIP6963!==!1),U.setEnableNetworkSwitch(e.enableNetworkSwitch!==!1),U.setEnableAuthLogger(e.enableAuthLogger!==!1),U.setCustomRpcUrls(e.customRpcUrls),U.setEnableEmbedded(e.enableEmbedded),U.setAllWallets(e.allWallets),U.setIncludeWalletIds(e.includeWalletIds),U.setExcludeWalletIds(e.excludeWalletIds),U.setFeaturedWalletIds(e.featuredWalletIds),U.setTokens(e.tokens),U.setTermsConditionsUrl(e.termsConditionsUrl),U.setPrivacyPolicyUrl(e.privacyPolicyUrl),U.setCustomWallets(e.customWallets),U.setFeatures(e.features),U.setAllowUnsupportedChain(e.allowUnsupportedChain),U.setUniversalProviderConfigOverride(e.universalProviderConfigOverride),U.setPreferUniversalLinks(e.experimental_preferUniversalLinks),U.setDefaultAccountTypes(e.defaultAccountTypes);const t=ge.getPreferredAccountTypes()||{},i={...U.state.defaultAccountTypes,...t};z.setPreferredAccountTypes(i);const n=this.getDefaultMetaData();if(!e.metadata&&n&&(e.metadata=n),U.setMetadata(e.metadata),U.setDisableAppend(e.disableAppend),U.setEnableEmbedded(e.enableEmbedded),U.setSIWX(e.siwx),!e.projectId){$t.open(ft.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED,"error");return}if(((o=e.adapters)==null?void 0:o.find(a=>a.namespace===te.CHAIN.EVM))&&e.siweConfig){if(e.siwx)throw new Error("Cannot set both `siweConfig` and `siwx` options");U.setSIWX(e.siweConfig.mapToSIWX())}}getDefaultMetaData(){var e,t,i,n;return xe.isClient()?{name:((t=(e=document.getElementsByTagName("title"))==null?void 0:e[0])==null?void 0:t.textContent)||"",description:((i=document.querySelector('meta[property="og:description"]'))==null?void 0:i.content)||"",url:window.location.origin,icons:[((n=document.querySelector('link[rel~="icon"]'))==null?void 0:n.href)||""]}:null}setUnsupportedNetwork(e){const t=this.getActiveChainNamespace();if(t){const i=Qt.getUnsupportedNetwork(`${t}:${e}`);S.setActiveCaipNetwork(i)}}getDefaultNetwork(){return Qt.getCaipNetworkFromStorage(this.defaultCaipNetwork)}extendCaipNetwork(e,t){return Qt.extendCaipNetwork(e,{customNetworkImageUrls:t.chainImages,projectId:t.projectId})}extendCaipNetworks(e){return Qt.extendCaipNetworks(e.networks,{customNetworkImageUrls:e.chainImages,customRpcUrls:e.customRpcUrls,projectId:e.projectId})}extendDefaultCaipNetwork(e){const t=e.networks.find(n=>{var r;return n.id===((r=e.defaultNetwork)==null?void 0:r.id)});return t?Qt.extendCaipNetwork(t,{customNetworkImageUrls:e.chainImages,customRpcUrls:e.customRpcUrls,projectId:e.projectId}):void 0}async disconnectNamespace(e){try{const t=this.getAdapter(e),i=Q.getProvider(e),n=Q.getProviderId(e),{caipAddress:r}=S.getAccountData(e)||{};this.setLoading(!0,e),r&&(t!=null&&t.disconnect)&&await t.disconnect({provider:i,providerType:n}),ge.removeConnectedNamespace(e),Q.resetChain(e),this.setUser(void 0,e),this.setStatus("disconnected",e),this.setConnectedWalletInfo(void 0,e),ee.removeConnectorId(e),S.resetAccount(e),S.resetNetwork(e),this.setLoading(!1,e)}catch(t){throw this.setLoading(!1,e),new Error(`Failed to disconnect chain ${e}: ${t.message}`)}}createClients(){this.connectionControllerClient={connectWalletConnect:async()=>{var r;const e=S.state.activeChain,t=this.getAdapter(e),i=(r=this.getCaipNetwork(e))==null?void 0:r.id;if(!t)throw new Error("Adapter not found");const n=await t.connectWalletConnect(i);this.close(),this.setClientId((n==null?void 0:n.clientId)||null),ge.setConnectedNamespaces([...S.state.chains.keys()]),this.chainNamespaces.forEach(o=>{ee.setConnectorId(rt.CONNECTOR_TYPE_WALLET_CONNECT,o)}),await this.syncWalletConnectAccount()},connectExternal:async({id:e,info:t,type:i,provider:n,chain:r,caipNetwork:o,socialUri:a})=>{var w,p,m,g,I,_;const c=S.state.activeChain,l=r||c,h=this.getAdapter(l);if(r&&r!==c&&!o){const T=this.getCaipNetworks().find(P=>P.chainNamespace===r);T&&this.setCaipNetwork(T)}if(!h)throw new Error("Adapter not found");const u=this.getCaipNetwork(l),d=await h.connect({id:e,info:t,type:i,provider:n,socialUri:a,chainId:(o==null?void 0:o.id)||(u==null?void 0:u.id),rpcUrl:((m=(p=(w=o==null?void 0:o.rpcUrls)==null?void 0:w.default)==null?void 0:p.http)==null?void 0:m[0])||((_=(I=(g=u==null?void 0:u.rpcUrls)==null?void 0:g.default)==null?void 0:I.http)==null?void 0:_[0])});if(!d)return;ge.addConnectedNamespace(l),this.syncProvider({...d,chainNamespace:l});const f=z.state.allAccounts,{accounts:y}=(f==null?void 0:f.length)>0?{accounts:[...f]}:await h.getAccounts({namespace:l,id:e});this.setAllAccounts(y,l),this.setStatus("connected",l),this.syncConnectedWalletInfo(l)},reconnectExternal:async({id:e,info:t,type:i,provider:n})=>{var a;const r=S.state.activeChain,o=this.getAdapter(r);o!=null&&o.reconnect&&(await(o==null?void 0:o.reconnect({id:e,info:t,type:i,provider:n,chainId:(a=this.getCaipNetwork())==null?void 0:a.id})),ge.addConnectedNamespace(r),this.syncConnectedWalletInfo(r))},disconnect:async e=>{const t=Ho(e);try{const i=await Promise.allSettled(t.map(async([r])=>this.disconnectNamespace(r)));Fo.resetSend(),Oe.resetWcConnection(),await gr.clearSessions(),ee.setFilterByNamespace(void 0);const n=i.filter(r=>r.status==="rejected");if(n.length>0)throw new Error(n.map(r=>r.reason.message).join(", "));ge.deleteConnectedSocialProvider(),Zt.sendEvent({type:"track",event:"DISCONNECT_SUCCESS",properties:{namespace:e||"all"}})}catch(i){throw new Error(`Failed to disconnect chains: ${i.message}`)}},checkInstalled:e=>e?e.some(t=>{var i;return!!((i=window.ethereum)!=null&&i[String(t)])}):!!window.ethereum,signMessage:async e=>{const t=this.getAdapter(S.state.activeChain),i=await(t==null?void 0:t.signMessage({message:e,address:z.state.address,provider:Q.getProvider(S.state.activeChain)}));return(i==null?void 0:i.signature)||""},sendTransaction:async e=>{const t=e.chainNamespace;if(ye.SEND_SUPPORTED_NAMESPACES.includes(t)){const i=this.getAdapter(S.state.activeChain),n=Q.getProvider(t),r=await(i==null?void 0:i.sendTransaction({...e,caipNetwork:this.getCaipNetwork(),provider:n}));return(r==null?void 0:r.hash)||""}return""},estimateGas:async e=>{if(e.chainNamespace===te.CHAIN.EVM){const t=this.getAdapter(S.state.activeChain),i=Q.getProvider(S.state.activeChain),n=this.getCaipNetwork();if(!n)throw new Error("CaipNetwork is undefined");const r=await(t==null?void 0:t.estimateGas({...e,provider:i,caipNetwork:n}));return(r==null?void 0:r.gas)||0n}return 0n},getEnsAvatar:async()=>{var e;return await this.syncIdentity({address:z.state.address,chainId:Number((e=this.getCaipNetwork())==null?void 0:e.id),chainNamespace:S.state.activeChain}),z.state.profileImage||!1},getEnsAddress:async e=>await Rs.resolveReownName(e),writeContract:async e=>{const t=this.getAdapter(S.state.activeChain),i=this.getCaipNetwork(),n=this.getCaipAddress(),r=Q.getProvider(S.state.activeChain);if(!i||!n)throw new Error("CaipNetwork or CaipAddress is undefined");const o=await(t==null?void 0:t.writeContract({...e,caipNetwork:i,provider:r,caipAddress:n}));return o==null?void 0:o.hash},parseUnits:(e,t)=>{const i=this.getAdapter(S.state.activeChain);return(i==null?void 0:i.parseUnits({value:e,decimals:t}))??0n},formatUnits:(e,t)=>{const i=this.getAdapter(S.state.activeChain);return(i==null?void 0:i.formatUnits({value:e,decimals:t}))??"0"},getCapabilities:async e=>{const t=this.getAdapter(S.state.activeChain);return await(t==null?void 0:t.getCapabilities(e))},grantPermissions:async e=>{const t=this.getAdapter(S.state.activeChain);return await(t==null?void 0:t.grantPermissions(e))},revokePermissions:async e=>{const t=this.getAdapter(S.state.activeChain);return t!=null&&t.revokePermissions?await t.revokePermissions(e):"0x"},walletGetAssets:async e=>{const t=this.getAdapter(S.state.activeChain);return await(t==null?void 0:t.walletGetAssets(e))??{}},updateBalance:e=>{const t=this.getCaipNetwork(e);!t||!z.state.address||this.updateNativeBalance(z.state.address,t==null?void 0:t.id,e)}},this.networkControllerClient={switchCaipNetwork:async e=>await this.switchCaipNetwork(e),getApprovedCaipNetworksData:async()=>this.getApprovedCaipNetworksData()},Oe.setClient(this.connectionControllerClient)}getApprovedCaipNetworksData(){var t,i,n,r,o;if(Q.getProviderId(S.state.activeChain)===rt.CONNECTOR_TYPE_WALLET_CONNECT){const a=(i=(t=this.universalProvider)==null?void 0:t.session)==null?void 0:i.namespaces;return{supportsAllNetworks:((o=(r=(n=this.universalProvider)==null?void 0:n.session)==null?void 0:r.peer)==null?void 0:o.metadata.name)==="MetaMask Wallet",approvedCaipNetworkIds:this.getChainsFromNamespaces(a)}}return{supportsAllNetworks:!0,approvedCaipNetworkIds:[]}}async switchCaipNetwork(e){if(!e)return;const t=e.chainNamespace;if(this.getAddressByChainNamespace(e.chainNamespace)){const n=Q.getProvider(t),r=Q.getProviderId(t);if(e.chainNamespace===S.state.activeChain){const o=this.getAdapter(t);await(o==null?void 0:o.switchNetwork({caipNetwork:e,provider:n,providerType:r}))}else if(this.setCaipNetwork(e),r===rt.CONNECTOR_TYPE_WALLET_CONNECT)this.syncWalletConnectAccount();else{const o=this.getAddressByChainNamespace(t);o&&this.syncAccount({address:o,chainId:e.id,chainNamespace:t})}}else this.setCaipNetwork(e)}getChainsFromNamespaces(e={}){return Object.values(e).flatMap(t=>{const i=t.chains||[],n=t.accounts.map(r=>{const{chainId:o,chainNamespace:a}=Ye.parseCaipAddress(r);return`${a}:${o}`});return Array.from(new Set([...i,...n]))})}createAdapters(e){return this.createClients(),this.chainNamespaces.reduce((t,i)=>{var r;const n=e==null?void 0:e.find(o=>o.namespace===i);return n?(n.construct({namespace:i,projectId:(r=this.options)==null?void 0:r.projectId,networks:this.getCaipNetworks()}),t[i]=n):t[i]=new Yd({namespace:i,networks:this.getCaipNetworks()}),t},{})}async initChainAdapter(e){var t;this.onConnectors(e),this.listenAdapter(e),await((t=this.chainAdapters)==null?void 0:t[e].syncConnectors(this.options,this)),await this.createUniversalProviderForAdapter(e)}async initChainAdapters(){await Promise.all(this.chainNamespaces.map(async e=>{await this.initChainAdapter(e)}))}onConnectors(e){const t=this.getAdapter(e);t==null||t.on("connectors",this.setConnectors.bind(this))}listenAdapter(e){const t=this.getAdapter(e);if(!t)return;const i=ge.getConnectionStatus();i==="connected"?this.setStatus("connecting",e):i==="disconnected"?(ge.clearAddressCache(),this.setStatus(i,e)):this.setStatus(i,e),t.on("switchNetwork",({address:n,chainId:r})=>{const o=this.getCaipNetworks().find(l=>l.id===r||l.caipNetworkId===r),a=S.state.activeChain===e,c=S.getAccountProp("address",e);if(o){const l=a&&n?n:c;l&&this.syncAccount({address:l,chainId:o.id,chainNamespace:e})}else this.setUnsupportedNetwork(r)}),t.on("disconnect",this.disconnect.bind(this,e)),t.on("connections",n=>{this.setConnections(n,e)}),t.on("pendingTransactions",()=>{const n=z.state.address,r=S.state.activeCaipNetwork;!n||!(r!=null&&r.id)||this.updateNativeBalance(n,r.id,r.chainNamespace)}),t.on("accountChanged",({address:n,chainId:r})=>{var a,c;const o=S.state.activeChain===e;o&&r?this.syncAccount({address:n,chainId:r,chainNamespace:e}):o&&((a=S.state.activeCaipNetwork)!=null&&a.id)?this.syncAccount({address:n,chainId:(c=S.state.activeCaipNetwork)==null?void 0:c.id,chainNamespace:e}):this.syncAccountInfo(n,r,e),this.syncAllAccounts(e)})}async createUniversalProviderForAdapter(e){var t,i,n;await this.getUniversalProvider(),this.universalProvider&&((n=(i=(t=this.chainAdapters)==null?void 0:t[e])==null?void 0:i.setUniversalProvider)==null||n.call(i,this.universalProvider))}async syncExistingConnection(){await Promise.allSettled(this.chainNamespaces.map(e=>this.syncNamespaceConnection(e)))}async syncNamespaceConnection(e){try{e===te.CHAIN.EVM&&xe.isSafeApp()&&ee.setConnectorId(te.CONNECTOR_ID.SAFE,e);const t=ee.getConnectorId(e);switch(this.setStatus("connecting",e),t){case te.CONNECTOR_ID.WALLET_CONNECT:await this.syncWalletConnectAccount();break;case te.CONNECTOR_ID.AUTH:break;default:await this.syncAdapterConnection(e)}}catch(t){console.warn("AppKit couldn't sync existing connection",t),this.setStatus("disconnected",e)}}async syncAdapterConnection(e){var a,c,l;const t=this.getAdapter(e),i=ee.getConnectorId(e),n=this.getCaipNetwork(e),o=ee.getConnectors(e).find(h=>h.id===i);try{if(!t||!o)throw new Error(`Adapter or connector not found for namespace ${e}`);if(!(n!=null&&n.id))throw new Error("CaipNetwork not found");const h=await(t==null?void 0:t.syncConnection({namespace:e,id:o.id,chainId:n.id,rpcUrl:(l=(c=(a=n==null?void 0:n.rpcUrls)==null?void 0:a.default)==null?void 0:c.http)==null?void 0:l[0]}));if(h){const u=await(t==null?void 0:t.getAccounts({namespace:e,id:o.id}));u&&u.accounts.length>0?this.setAllAccounts(u.accounts,e):this.setAllAccounts([xe.createAccount(e,h.address,"eoa")],e),this.syncProvider({...h,chainNamespace:e}),await this.syncAccount({...h,chainNamespace:e}),this.setStatus("connected",e)}else this.setStatus("disconnected",e)}catch{this.setStatus("disconnected",e)}}async syncWalletConnectAccount(){const e=this.chainNamespaces.map(async t=>{var a,c,l,h,u;const i=this.getAdapter(t),n=((h=(l=(c=(a=this.universalProvider)==null?void 0:a.session)==null?void 0:c.namespaces)==null?void 0:l[t])==null?void 0:h.accounts)||[],r=(u=S.state.activeCaipNetwork)==null?void 0:u.id,o=n.find(d=>{const{chainId:f}=Ye.parseCaipAddress(d);return f===(r==null?void 0:r.toString())})||n[0];if(o){const d=Ye.validateCaipAddress(o),{chainId:f,address:y}=Ye.parseCaipAddress(d);if(Q.setProviderId(t,rt.CONNECTOR_TYPE_WALLET_CONNECT),this.caipNetworks&&S.state.activeCaipNetwork&&(i==null?void 0:i.namespace)!==te.CHAIN.EVM){const w=i==null?void 0:i.getWalletConnectProvider({caipNetworks:this.getCaipNetworks(),provider:this.universalProvider,activeCaipNetwork:S.state.activeCaipNetwork});Q.setProvider(t,w)}else Q.setProvider(t,this.universalProvider);ee.setConnectorId(te.CONNECTOR_ID.WALLET_CONNECT,t),ge.addConnectedNamespace(t),this.syncWalletConnectAccounts(t),await this.syncAccount({address:y,chainId:f,chainNamespace:t})}else this.setStatus("disconnected",t);this.syncConnectedWalletInfo(t),await S.setApprovedCaipNetworksData(t)});await Promise.all(e)}syncWalletConnectAccounts(e){var i,n,r,o,a;const t=(a=(o=(r=(n=(i=this.universalProvider)==null?void 0:i.session)==null?void 0:n.namespaces)==null?void 0:r[e])==null?void 0:o.accounts)==null?void 0:a.map(c=>{const{address:l}=Ye.parseCaipAddress(c);return l}).filter((c,l,h)=>h.indexOf(c)===l);t&&this.setAllAccounts(t.map(c=>xe.createAccount(e,c,e==="bip122"?"payment":"eoa")),e)}syncProvider({type:e,provider:t,id:i,chainNamespace:n}){Q.setProviderId(n,e),Q.setProvider(n,t),ee.setConnectorId(i,n)}async syncAllAccounts(e){const t=ee.getConnectorId(e);if(!t)return;const i=this.getAdapter(e),n=await(i==null?void 0:i.getAccounts({namespace:e,id:t}));n&&n.accounts.length>0&&this.setAllAccounts(n.accounts,e)}async syncAccount(e){var u,d;const t=e.chainNamespace===S.state.activeChain,i=S.getCaipNetworkByNamespace(e.chainNamespace,e.chainId),{address:n,chainId:r,chainNamespace:o}=e,{chainId:a}=ge.getActiveNetworkProps(),c=r||a,l=((u=S.state.activeCaipNetwork)==null?void 0:u.name)===te.UNSUPPORTED_NETWORK_NAME,h=S.getNetworkProp("supportsAllNetworks",o);if(this.setStatus("connected",o),!(l&&!h)&&c){let f=this.getCaipNetworks().find(p=>p.id.toString()===c.toString()),y=this.getCaipNetworks().find(p=>p.chainNamespace===o);if(!h&&!f&&!y){const p=this.getApprovedCaipNetworkIds()||[],m=p.find(I=>{var _;return((_=Ye.parseCaipNetworkId(I))==null?void 0:_.chainId)===c.toString()}),g=p.find(I=>{var _;return((_=Ye.parseCaipNetworkId(I))==null?void 0:_.chainNamespace)===o});f=this.getCaipNetworks().find(I=>I.caipNetworkId===m),y=this.getCaipNetworks().find(I=>I.caipNetworkId===g||"deprecatedCaipNetworkId"in I&&I.deprecatedCaipNetworkId===g)}const w=f||y;(w==null?void 0:w.chainNamespace)===S.state.activeChain?U.state.enableNetworkSwitch&&!U.state.allowUnsupportedChain&&((d=S.state.activeCaipNetwork)==null?void 0:d.name)===te.UNSUPPORTED_NETWORK_NAME?S.showUnsupportedChainUI():this.setCaipNetwork(w):t||i&&this.setCaipNetworkOfNamespace(i,o),this.syncConnectedWalletInfo(o),Vo.isLowerCaseMatch(n,z.state.address)||this.syncAccountInfo(n,w==null?void 0:w.id,o),t?await this.syncBalance({address:n,chainId:w==null?void 0:w.id,chainNamespace:o}):await this.syncBalance({address:n,chainId:i==null?void 0:i.id,chainNamespace:o})}}async syncAccountInfo(e,t,i){const n=this.getCaipAddress(i),r=t||(n==null?void 0:n.split(":")[1]);if(!r)return;const o=`${i}:${r}:${e}`;this.setCaipAddress(o,i),await this.syncIdentity({address:e,chainId:r,chainNamespace:i})}async syncReownName(e,t){try{const i=await this.getReownName(e);if(i[0]){const n=i[0];this.setProfileName(n.name,t)}else this.setProfileName(null,t)}catch{this.setProfileName(null,t)}}syncConnectedWalletInfo(e){var n;const t=ee.getConnectorId(e),i=Q.getProviderId(e);if(i===rt.CONNECTOR_TYPE_ANNOUNCED||i===rt.CONNECTOR_TYPE_INJECTED){if(t){const r=this.getConnectors().find(o=>o.id===t);if(r){const{info:o,name:a,imageUrl:c}=r,l=c||this.getConnectorImage(r);this.setConnectedWalletInfo({name:a,icon:l,...o},e)}}}else if(i===rt.CONNECTOR_TYPE_WALLET_CONNECT){const r=Q.getProvider(e);r!=null&&r.session&&this.setConnectedWalletInfo({...r.session.peer.metadata,name:r.session.peer.metadata.name,icon:(n=r.session.peer.metadata.icons)==null?void 0:n[0]},e)}else if(t&&t===te.CONNECTOR_ID.COINBASE){const r=this.getConnectors().find(o=>o.id===te.CONNECTOR_ID.COINBASE);this.setConnectedWalletInfo({name:"Coinbase Wallet",icon:this.getConnectorImage(r)},e)}}async syncBalance(e){!zo.getNetworksByNamespace(this.getCaipNetworks(),e.chainNamespace).find(i=>{var n;return i.id.toString()===((n=e.chainId)==null?void 0:n.toString())})||!e.chainId||await this.updateNativeBalance(e.address,e.chainId,e.chainNamespace)}async ready(){await this.readyPromise}async updateNativeBalance(e,t,i){const n=this.getAdapter(i),r=S.getCaipNetworkByNamespace(i,t);if(n){const o=await n.getBalance({address:e,chainId:t,caipNetwork:r,tokens:this.options.tokens});return this.setBalance(o.balance,o.symbol,i),o}}async initializeUniversalAdapter(){var i,n,r,o,a,c,l,h,u,d;const e=Wo.createLogger((f,...y)=>{f&&this.handleAlertError(f),console.error(...y)}),t={projectId:(i=this.options)==null?void 0:i.projectId,metadata:{name:(n=this.options)!=null&&n.metadata?(r=this.options)==null?void 0:r.metadata.name:"",description:(o=this.options)!=null&&o.metadata?(a=this.options)==null?void 0:a.metadata.description:"",url:(c=this.options)!=null&&c.metadata?(l=this.options)==null?void 0:l.metadata.url:"",icons:(h=this.options)!=null&&h.metadata?(u=this.options)==null?void 0:u.metadata.icons:[""]},logger:e};U.setManualWCControl(!!((d=this.options)!=null&&d.manualWCControl)),this.universalProvider=this.options.universalProvider??await ji.init(t),this.listenWalletConnect()}listenWalletConnect(){this.universalProvider&&(this.universalProvider.on("display_uri",e=>{Oe.setUri(e)}),this.universalProvider.on("connect",Oe.finalizeWcConnection),this.universalProvider.on("disconnect",()=>{this.chainNamespaces.forEach(e=>{this.resetAccount(e)}),Oe.resetWcConnection()}),this.universalProvider.on("chainChanged",e=>{const t=this.getCaipNetworks().find(n=>n.id==e),i=this.getCaipNetwork();if(!t){this.setUnsupportedNetwork(e);return}(i==null?void 0:i.id)!==(t==null?void 0:t.id)&&this.setCaipNetwork(t)}),this.universalProvider.on("session_event",e=>{if(Rs.isSessionEventData(e)){const{name:t,data:i}=e.params.event;t==="accountsChanged"&&Array.isArray(i)&&xe.isCaipAddress(i[0])&&this.syncAccount(Ye.parseCaipAddress(i[0]))}}))}createUniversalProvider(){var e;return!this.universalProviderInitPromise&&xe.isClient()&&((e=this.options)!=null&&e.projectId)&&(this.universalProviderInitPromise=this.initializeUniversalAdapter()),this.universalProviderInitPromise}async getUniversalProvider(){if(!this.universalProvider)try{await this.createUniversalProvider()}catch(e){Zt.sendEvent({type:"error",event:"INTERNAL_SDK_ERROR",properties:{errorType:"UniversalProviderInitError",errorMessage:e instanceof Error?e.message:"Unknown",uncaught:!1}}),console.error("AppKit:getUniversalProvider - Cannot create provider",e)}return this.universalProvider}handleAlertError(e){const t=Object.entries(ft.UniversalProviderErrors).find(([,{message:a}])=>e.message.includes(a)),[i,n]=t??[],{message:r,alertErrorKey:o}=n??{};if(i&&r&&!this.reportedAlertErrors[i]){const a=ft.ALERT_ERRORS[o];a&&($t.open(a,"error"),this.reportedAlertErrors[i]=!0)}}getAdapter(e){var t;if(e)return(t=this.chainAdapters)==null?void 0:t[e]}createAdapter(e){var n;if(!e)return;const t=e.namespace;if(!t)return;this.createClients();const i=e;i.namespace=t,i.construct({namespace:t,projectId:(n=this.options)==null?void 0:n.projectId,networks:this.getCaipNetworks()}),this.chainNamespaces.includes(t)||this.chainNamespaces.push(t),this.chainAdapters&&(this.chainAdapters[t]=i)}async open(e){if(await this.injectModalUi(),e!=null&&e.uri&&Oe.setUri(e.uri),e!=null&&e.arguments)switch(e==null?void 0:e.view){case"Swap":return Xt.open({...e,data:{swap:e.arguments}})}return Xt.open(e)}async close(){await this.injectModalUi(),Xt.close()}setLoading(e,t){Xt.setLoading(e,t)}async disconnect(e){await Oe.disconnect(e)}getSIWX(){return U.state.siwx}getError(){return""}getChainId(){var e;return(e=S.state.activeCaipNetwork)==null?void 0:e.id}async switchNetwork(e){const t=this.getCaipNetworks().find(i=>i.id===e.id);if(!t){$t.open(ft.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND,"error");return}await S.switchActiveNetwork(t)}getWalletProvider(){return S.state.activeChain?Q.state.providers[S.state.activeChain]:null}getWalletProviderType(){return Q.getProviderId(S.state.activeChain)}subscribeProviders(e){return Q.subscribeProviders(e)}getThemeMode(){return Be.state.themeMode}getThemeVariables(){return Be.state.themeVariables}setThemeMode(e){Be.setThemeMode(e),Ko(Be.state.themeMode)}setTermsConditionsUrl(e){U.setTermsConditionsUrl(e)}setPrivacyPolicyUrl(e){U.setPrivacyPolicyUrl(e)}setThemeVariables(e){Be.setThemeVariables(e),Go(Be.state.themeVariables)}subscribeTheme(e){return Be.subscribe(e)}getWalletInfo(){return z.state.connectedWalletInfo}getAccount(e){var o;const t=ee.getAuthConnector(e),i=S.getAccountData(e),n=S.state.activeChain,r=ge.getConnectedConnectorId(e||n);if(i)return{allAccounts:i.allAccounts,caipAddress:i.caipAddress,address:xe.getPlainAddress(i.caipAddress),isConnected:!!i.caipAddress,status:i.status,embeddedWalletInfo:t&&r===te.CONNECTOR_ID.AUTH?{user:i.user?{...i.user,username:ge.getConnectedSocialUsername()}:void 0,authProvider:i.socialProvider||"email",accountType:(o=i.preferredAccountTypes)==null?void 0:o[e||n],isSmartAccountDeployed:!!i.smartAccountDeployed}:void 0}}subscribeAccount(e,t){const i=()=>{const n=this.getAccount(t);n&&e(n)};t?S.subscribeChainProp("accountState",i,t):S.subscribe(i),ee.subscribe(i)}subscribeNetwork(e){return S.subscribe(({activeCaipNetwork:t})=>{e({caipNetwork:t,chainId:t==null?void 0:t.id,caipNetworkId:t==null?void 0:t.caipNetworkId})})}subscribeWalletInfo(e){return z.subscribeKey("connectedWalletInfo",e)}subscribeShouldUpdateToAddress(e){z.subscribeKey("shouldUpdateToAddress",e)}subscribeCaipNetworkChange(e){S.subscribeKey("activeCaipNetwork",e)}getState(){return zi.state}subscribeState(e){return zi.subscribe(e)}showErrorMessage(e){Wi.showError(e)}showSuccessMessage(e){Wi.showSuccess(e)}getEvent(){return{...Zt.state}}subscribeEvents(e){return Zt.subscribe(e)}replace(e){ws.replace(e)}redirect(e){ws.push(e)}popTransactionStack(e){ws.popTransactionStack(e)}isOpen(){return Xt.state.open}isTransactionStackEmpty(){return ws.state.transactionStack.length===0}static getInstance(){return this.instance}updateFeatures(e){U.setFeatures(e)}updateRemoteFeatures(e){U.setRemoteFeatures(e)}updateOptions(e){const i={...U.state||{},...e};U.setOptions(i)}setConnectMethodsOrder(e){U.setConnectMethodsOrder(e)}setWalletFeaturesOrder(e){U.setWalletFeaturesOrder(e)}setCollapseWallets(e){U.setCollapseWallets(e)}setSocialsOrder(e){U.setSocialsOrder(e)}getConnectMethodsOrder(){return Jo.getConnectOrderMethod(U.state.features,ee.getConnectors())}addNetwork(e,t){if(this.chainAdapters&&!this.chainAdapters[e])throw new Error(`Adapter for namespace ${e} doesn't exist`);const i=this.extendCaipNetwork(t,this.options);this.getCaipNetworks().find(n=>n.id===i.id)||S.addNetwork(i)}removeNetwork(e,t){if(this.chainAdapters&&!this.chainAdapters[e])throw new Error(`Adapter for namespace ${e} doesn't exist`);this.getCaipNetworks().find(n=>n.id===t)&&S.removeNetwork(e,t)}}let ar=!1;class ep extends Xd{async open(e){ee.isConnected()||await super.open(e)}async close(){await super.close(),this.options.manualWCControl&&Oe.finalizeWcConnection()}async syncIdentity(e){return Promise.resolve()}async syncBalance(e){return Promise.resolve()}async injectModalUi(){if(!ar&&xe.isClient()){if(await li(()=>import("./basic-CL2WxW2N.js"),__vite__mapDeps([0,1,2,3,4])),await li(()=>import("./w3m-modal-XXDCI2nP.js"),__vite__mapDeps([5,1,2,3,4])),!document.querySelector("w3m-modal")){const t=document.createElement("w3m-modal");!U.state.disableAppend&&!U.state.enableEmbedded&&document.body.insertAdjacentElement("beforeend",t)}ar=!0}}}const tp="1.7.8";function ap(s){return new ep({...s,basic:!0,sdkVersion:`html-core-${tp}`})}export{ep as AppKit,ap as createAppKit};
